import time
import sys, os
import argparse

import cProfile
import gc
gc.disable()

class CoreRBAC(process):
  """
  Core RBAC keeps several sets including the following:

    USERS: set of users
    ROLES: set of roles
    PERMS: set of permissions
    UR: set of user-role pairs
    PR: set of permission-role pairs

  with constraints:

    UR subset USERS * ROLES
    PR subset PERMS * ROLES

  update functions for each set, subject to the constraints above:

    AddUser, DeleteUser, AddRole, DeleteRole, AddPerm, DeletePerm
    AddUR, DeleteUR, AddPR, DeletePR
    each Add has pre-conditions:
      the element is not yet in and the constraints will not be violated. 
    each Delete has the pre-condition that the element is in,
      and maintains the constraints.

  query functions including the following:
  
    AssignedUsers(role): the set of users assigned to role in UR
    AssignedRoles(user): the set of roles assigned to user in UR
    UserPermissions(user): 
      the set of permissions assigned to the roles assigned to user
  """

  def setup(_users,_roles,_ur):
    self.USERS = _users
    self.ROLES = _roles
    self.PERMS = set()
    self.UR = _ur         # UR subset USERS * ROLES
    self.PR = set()         # PR subset PERMS * ROLES
    # self.workload = _workload

  def AddUser(user):        # pre-condition: user not in USERS
    USERS.add(user)

  def DeleteUser(user):     # pre-condition: user in USERS
    UR -= setof((user,r), r in ROLES) # maintain UR
    USERS.remove(user)

  def AddRole(role):        # pre: role not in ROLES
    ROLES.add(role)

  def DeleteRole(role):     # pre: role in ROLES
    UR -= setof((u,role), u in USERS) # maintain UR
    PR -= setof((p,role), p in PERMS) # maintain PR
    ROLES.remove(role)

  # missing in ANSI standard
  def AddPerm(perm):        # pre: perm not in PERMS
    PERMS.add(perm)

  # missing in ANSI standard
  def DeletePerm(perm):     # pre: perm in PERMS
    PR -= setof((perm,r), r in ROLES) # maintain PR
    PERMS.remove(perm)

  # called AssignUser in ANSI standard
  def AddUR(user, role):
    # pre: user in USERS, role in ROLES, (user,role) not in UR
    UR.add((user,role))

  # called DeassignUser in ANSI standard
  def DeleteUR(user, role):  # pre: (user,role) in UR
    UR.remove((user,role))

  # called GrantPermission in ANSI standard
  def AddPR(perm, role):
    # pre: perm in PERMS, role in ROLES, (perm,role) not in PR
    PR.add((perm,role))

  # called RevokePermission in ANSI standard
  def DeletePR(perm, role):  # pre: (perm,role) in PR
    PR.remove((perm,role))

  def AssignedUsers(role):  # pre: role in ROLES
    """the set of users assigned to role in UR"""
    return setof(u, (u,_role) in UR)

  def AssignedRoles(user):  # pre: user in USERS
    """the set of roles assigned to user in UR"""
    return setof(r, (_user,r) in UR)

  def UserPermissions(user):  # pre: user in USERS
    """the set of permissions assigned to the roles assigned to user"""
    return setof(p, (_user,r) in UR, (p,r) in PR)


class HierarchicalRBAC(CoreRBAC,process):
  """
  Hierarchical RBAC keeps also a role hierarchy:

    RH: set of pairs of roles, called ascendant and descendant roles,
    where an ascendant role inherits permissions from a descendant role

  with constraints:

    RH subset ROLES * ROLES, and RH is acyclic

  update functions for RH, subject to the constraints above:

    AddInheritance(asc,desc)
    DeleteInheritance(asc,desc)
    with the same kinds of pre-conditions as updates in CoreRBAC

  query functions including the following:

    trans:
      the transitive closure of role hierarchy union reflexive role pairs
    AuthorizedUsers(role):
      the set of users of role or ascendant roles of role
    AuthorizedRoles(user):
      the set of roles of user or descendant roles of the roles
  """

  def setup(_users,_roles,_ur,_rh,_workload):
    super().setup(_users,_roles,_ur)
    self.RH = _rh  # RH subset ROLES * ROLES, where asc inh desc
    self.workload = _workload

  def AddInheritance(a,d):
    # pre: a in ROLES, d in ROLES, (a,d) not in RH, (d,a) not in RH, a!=d
    RH.add((a,d))

  def DeleteInheritance(a,d):  # pre: (a,d) in RH
    RH.remove((a,d))

  def AuthorizedUsers(_role):
    """the set of users of role or ascendant roles of role"""
    transRH = trans(RH)
    return setof(u, (u,asc) in UR, (asc,_role) in transRH)

  # rest of this class: some possible calls, etc. to be worked on
  def trans(E):
    pass
  def run():
    utime1, stime1, cutime1, cstime1, elapsed_time1 = os.times()
    for op,pr in workload:
      if op in {'AddUser','DeleteUser','AddRole','DeleteRole','AuthorizedUsers'}:
        for i in pr:
          eval('self.'+op)(i)
      else:
        for i,j in pr:
          eval('self.'+op)(i,j)
    utime2, stime2, cutime2, cstime2, elapsed_time2 = os.times()
    print(elapsed_time2-elapsed_time1, utime2-utime1 + stime2-stime1 + cutime2-cutime1 + cstime2-cstime1)

class HRBAC_py(HierarchicalRBAC,process):  # using Python but no arg self in def
  
  def trans(E):
    T = E
    W = {(x,d) for (x,y) in T for (a,d) in E if y==a} - T
    while W:
      T.add(W.pop())
      W = {(x,d) for (x,y) in T for (a,d) in E if y==a} - T
    return T | {(r,r) for r in self.ROLES}  # dom(E)+ran(E) may < ROLES
  
  def AuthorizedUsers(role):  # assert role in self.ROLES
    transRH = self.trans(RH)
    user = self.USERS
    roles = self.ROLES
    ur = self.UR
    return set(u for u in user for asc in roles
               if (asc,role) in transRH and (u,asc) in ur)

class HRBAC_set(HierarchicalRBAC,process):  # using DistAlgo set queries
  
  def trans(E):
    T = E
    while some((x,y) in T, (y,z) in E, has= (x,z) not in T):
      T.add((x,z))
    return T | setof((r,r), r in ROLES)
  
  def AuthorizedUsers(role):
    transRH = self.trans(RH)
    return setof(u, (u,asc) in UR, (asc,_role) in transRH)

class HRBAC_transRH_rs(HierarchicalRBAC,process):
  
  def setup(_users,_roles,_ur,_rh,_workload): 
    super().setup(_users,_roles,_ur,_rh,_workload)
    self.transRH = None
  
  def AuthorizedUsers(role):
    return setof(u, (u,asc) in UR, (asc,_role) in transRH)
  
  def rules ():
    transRH(x,y), if_(RH(x,y))
    transRH(x,y), if_(RH(x,z), transRH(z,y))
    transRH(x,x), if_(ROLES(x)) # with this base case, don't need first rule

class HRBAC_trans_rules(HRBAC_py,process):
  
  def rules():
    path(x,y), if_(edge(x,y))
    path(x,y), if_(edge(x,z), path(z,y))
  
  def trans(E):  # use infer plus set query
    i = infer(rule='HRBAC_trans_rules', bindings=[('edge',E)], queries=['path'])
    return set(i) | setof((r,r), r in ROLES)

class HRBAC_trans_with_role_rules(HRBAC_py,process):
  
  def rules (name='trans_with_role_rules'): # with additional last rule
    path(x,y), if_(edge(x,y))
    path(x,y), if_(edge(x,z), path(z,y))
    path(x,x), if_(role(x))
  
  def trans(E):  # use infer only, pass in also ROLES
    return infer(rule='trans_with_role_rules', bindings=[('edge',E),('role',ROLES)], queries=['path'])

    
HandlerRoute = {
  'rule': HRBAC_trans_rules,
  'rolerule': HRBAC_trans_with_role_rules,
  'transRH': HRBAC_transRH_rs,
  'python': HRBAC_py,
  'distalgo': HRBAC_set
}
def main():
  config(channel is fifo, clock is lamport)
  parser = argparse.ArgumentParser()
  parser.add_argument('--numr', type= int, default= 500)  # number of roles (graph size)
  parser.add_argument('--numq', type= int, default= 50)   # unit of operations, e.g. 50 adding/deleting user 
  parser.add_argument('--q', type= int, default= 50)      # number of auth queries
  parser.add_argument('--mode', type= str, default= 'transRH')
  args=parser.parse_args()
  
  users = set(range(10*args.numr))
  roles = set(range(args.numr))
  rh = eval(open('./input/HR_'+str(args.numr)+'.py').read())
  ur = eval(open('./input/UR_'+str(args.numr)+'.py').read())
  workload = eval(open('./input/hrbacSequence_r'+str(args.numr)+'_q'+str(args.numq)+'_auth'+str(args.q)+'.py').read())
  
  if not os.path.exists('timing'):
    os.mkdir('timing')
  sys.stdout = open('./timing/timing_hrbac_%s_r%s_q%s_auth%s.txt' % (args.mode, args.numr, args.numq, args.q), 'a')
  
  if not args.mode in HandlerRoute:
    print('no such mode')
    sys.exit()
  
  o = new(HandlerRoute[args.mode],[users,roles,ur,rh,workload])
  start(o)