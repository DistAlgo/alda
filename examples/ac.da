"""
We consider Role-Based Access Control (RBAC) with 5 components:

  Core RBAC,
  Hierarchical RBAC, 
  Core RBAC with Static Separation of Duty constraint (also called Constrained RBAC),
  Hierarchical RBAC with Static Separation of Duty constraint, and
  Administrative RBAC.

excluding Distributed RBAC, at least for now.
"""

import hrbac

class CoreRBACwithSSD(CoreRBAC,process):
  """
  Core RBAC with SSD keeps also a set of SSD items, where each item has:

    a name, 
    a set of roles, and
    a cardinality c such that 1 <= c < count(roles)

  with constraints:

    all roles in all SSD items  subset ROLES

    for each user, for each SSD item,
      the number of assigned roles (AssignedRoles) of the user 
      that are in the item's roles 
      is no more than the item's cardinality.

  update functions, subject to the constraints above:
 
    CreateSsdSet(name, roles, c): add SSD item having name, roles, c
    DeleteSsdSet(name): delete SSD item having name
    AddSsdRoleMember(name, role): add role to SSD item name's roles
    DeleteSsdRoleMember(name, role): add role from SSD item name's roles
    SetSsdSetCardinality(name, c): set c to be SSD item name's cardinality 
    with the same kinds of pre-conditions as updates in CoreRBAC

  query functions including the following:
  
    SsdRoleSets(): the set of names of SSD items
    SsdRoleSetRoles(name): the set of roles in SSD item name
    SsdRoleSetCardinality(name): the cardinality of SSD item name
  """

  def setup(): 
    super.setup()
    self.SsdNAMES = set() # set of names of constraints
    self.SsdNR = set()    # set of pairs of name and role
                          # SsdNR subset SsdNAMES * ROLES
    self.SsdNC = dict()   # set of pairs of name and cardinality
                          # SsdNC: SsdNAMES -> int

  # SSD constraint, as post condition for all updates
  def check_constraint (name = SSD):
    return each(u in USERS, (name,c) in SsdNC, has=
                countof(r, r in AssignedRoles(u), (_name,r) in SsdNR) <= c)

  def AssignUser(user, role):
    CoreRBAC.AssignUser(user, role)

  def CreateSsdSet(name, roles, c):  # todo: last 2 not needed, by post
    # pre: name not in SsdNAMES, roles subset ROLES, 1 <= c < count(roles)
    SsdNAMES.add(name)
    SsdNR |= setof((name,r), r in roles)
    SsdNC.add((name,c))

  def DeleteSsdSet(name):  # pre: name in SsdNAMES  #don't need post SSD
    SsdNR -= setof((name,r), r in SsdRoleSetRoles(name))
    SsdNC.remove((name,SsdRoleSetCardinality(name)))
    SsdNAMES.remove(name)		      # delete ssd name last

  def AddSsdRoleMember(name, role):
    # pre: name in SsdNAMES, role in ROLES
    # pre: role not in SsdRoleSetRoles(name)
    SsdNR.add((name,role))

  def DeleteSsdRoleMember(name, role):
    # pre: name in SsdNAMES, role in SsdRoleSetRoles(name)
    SsdNR.remove((name,role))

  def SetSsdSetCardinality(name, c):
    # pre: name in SsdNAMES, SsdRoleSetCardinality(name) != c
    SsdNC.remove((name,SsdRoleSetCardinality(name)))
    SsdNC.add((name,c))

  def SsdRoleSets():
    return SsdNAMES

  def SsdRoleSetRoles(name):  # pre: name in SsdNAMES
    return setof(r, (_name,r) in SsdNR)

  def SsdRoleSetCardinality(name):  # pre: name in SsdNAMES
    return anyof(setof(c, (_name,c) in SsdNC))


class HierarchicalRBACwithSSD(HierarchicalRBAC,CoreRBACwithSSD,process):
  """
  Hierarchical RBAC with SSD combines all from
  Hierarchical RBAC and Core RBAC with SSD, except that 
  the SSD constraint uses AuthorizedRoles in place of AssignedRoles.
  """

  def setup(): 
    HierarchicalRBAC.setup()
    CoreRBACwithSSD.setup()

  # SSD constraint, as post condition for all updates
  def check_constraint (name = SSD):
    return each(u in USERS, (name,c) in SsdNC, has=
                countof(r, r in AuthorizedRoles(u), (_name,r) in SsdNR) <=c)


class AdminRBAC(HierarchicalRBACwithSSD):
  """
  Administrative RBAC for HierarchicalRBACwithSSD
  has optimization and planning functions:

    MineMinRoles:
      find a smallest set of roles with UR' and PR' assignments
      such that UR' * PR' = UR * PR

    MineMinRoleAssignments:
      find a smallest set of UR' and PR' assignments
      such that UR' * PR' = UR * PR = UP

    GetRolesPlan(user, roles, acts):
      find a sequence of actions, i.e., updates, in acts that
      allows user to get roles

    GetRolesShortestPlan(user, roles, acts):
      find a shortest sequence of actions, i.e., updates, in acts that
      allows user to get roles

  The first two can have a version that includes finding RH'.
  Any subset of updates can be used as acts; 
  all constraints must hold after each action.

  Administrative RBAC could also be for 
    CoreRBAC, HierarchicalRBAC, or CoreRBACwithSSD.
  """

  def setup(UP):
    HierarchicalRBACwithSSD.setup()

  def MineMinRoles():
    """
    find a smallest set of roles with UR' and PR' assignments
    such that UR' * PR' = UR * PR = UP
    """
    return anyof((R, UR', PR'), R subset ran(UR)&ran(PR),
                 UR' subset dom(UR)*R, PR' subset dom(PR)*R,
                 UR' * PR' = UR * PR, min R)

  def MineMinRoleAssignments():
    """
    find a smallest set of UR' and PR' assignments
    such that UR' * PR' = UR * PR = UP
    """
    return anyof((R, UR', PR'), R subset ran(UR)&ran(PR),
                 UR' subset dom(UR)*R, PR' subset dom(PR)*R,
                 UR' * PR' = UR * PR, min UR'+PR')

  def GetRolesPlan(user, roles, acts):
    """
    find a sequence of actions in acts that allows the user to get the
    set of roles
    """
    assume true
    seq = []
    while not each(r in roles, has= (_user,r) in UR):
      if some a in acts:
        do(a)
        seq.append(a)
      if some ('assign',user,role) in acts:
        AssignUser(user,role)
      if some ('deassign',user,role) in acts:
        DeassignUser(user,role)
    achieve anyof(seq: true)

  def GetRolesShortestPlan(user, roles, acts):
    """
    find a shortest sequence of actions in acts that allows the user
    to get the set of roles
    """
    assume true
    seq = []
    cost = 0
    while not each(r in roles, has= (_user,r) in UR):
      if some a in acts:
        do(a)
        seq.append(a)
        cost += 1
    achieve anyof(seq, cost: min cost)
    # todo: specify cost declaratively, and 
    # add action to sequence and add cost automatically


class DistRBAC(HierarchicalRBACwithSSD,process):
  """
  A Distributed RBAC process keeps also the following sets:

    OTHERS: set of other RBAC processes
    GuestR: set of pairs of a rbac-role pair and a guest role

  with constraints:

    domain(domain(GuestR)) subset OTHERS
    range(GuestR) subset ROLES

  update functions for each set subject to the constraints above:

    AddGuestRole, DeleteGuestRole
    AssignGuestRole, DeassignGuestRole

  query functions:

    GuestRoles (rbac,role): the set of guest roles for role of rbac
    OthersRoles(guest): the set of rbac-role pairs for role guest 

  Distributed RBAC can also be for only
    CoreRBAC, HierarchicalRBAC, or CoreRBACwithSSD,
    or Administrative RBAC for any of these.

  """

  def setup(OTHERS):
    HierarchicalRBACwithSSD.setup()
    GuestR = set()
  
  def run(): await(False) # todo: problems with non dist part, by RPC?

  def AddGuestRole(rbac,role,guest):
    GuestR.add(((rbac,role),guest))

  def DeleteGuestRole(rbac,role,guest): # pre: ((rbac,role),guest) in GuestR
    GuestR.remove(((rbac,role),guest))

  def GuestRoles(rbac, role):
    """the set of guest roles for role of rbac
    """
    return setof(guest, ((_rbac,_role),guest) in GuestR)

  def OthersRoles(guest):
    """the set of rbac-role pairs for role guest 
    """
    return setof((rbac,role), (rbac,role),_guest) in GuestR)

  def AssignGuestRole(user,rbac,role):
    """assign to user of role in rbac the corresponding guest roles
    """
    send(('credential',user,role), to= rbac)
    if await(received(('accept',user,role), from_=rbac)):
      for r in GuestRoles(rbac, role):
        AssignUser(user,r)

  def DeassignGuestRole(user,rbac,role):  # pre:
    """deassign from user of role in rbac the corresponding guest roles
    """
    for r in GuestRoles(rbac, role):
      DeassignUser(user,r)

  def receive(msg=('credential',user,role), from_= rbac):
    if (user,role) in UR:
      send(('accept',user,role), to=rbac)
    else: 
      send(('reject',user,role), to=rbac)


def main(): 
  r = new(RBAC,[])
