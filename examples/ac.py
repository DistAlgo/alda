# -*- generated by 1.0.12 -*-
import da
PatternExpr_1233 = da.pat.TuplePattern([da.pat.ConstantPattern('accept'), da.pat.BoundPattern('_BoundPattern1236_'), da.pat.BoundPattern('_BoundPattern1237_')])
PatternExpr_1240 = da.pat.BoundPattern('_BoundPattern1241_')
PatternExpr_1290 = da.pat.TuplePattern([da.pat.ConstantPattern('credential'), da.pat.FreePattern('user'), da.pat.FreePattern('role')])
PatternExpr_1299 = da.pat.FreePattern('rbac')
PatternExpr_1325 = da.pat.TuplePattern([da.pat.ConstantPattern('AddGuestUR'), da.pat.FreePattern('user'), da.pat.FreePattern('rbac'), da.pat.FreePattern('role')])
PatternExpr_1344 = da.pat.TuplePattern([da.pat.ConstantPattern('DeleteGuestUR'), da.pat.FreePattern('user'), da.pat.FreePattern('rbac'), da.pat.FreePattern('role')])
PatternExpr_1242 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern1248_')]), da.pat.TuplePattern([da.pat.ConstantPattern('accept'), da.pat.BoundPattern('_BoundPattern1252_'), da.pat.BoundPattern('_BoundPattern1253_')])])
_config_object = {}

class CoreRBAC(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([])

    def setup(self, **rest_1360):
        super().setup(**rest_1360)
        self._state.USERS = set()
        self._state.ROLES = set()
        self._state.PERMS = set()
        self._state.UR = set()
        self._state.PR = set()

    def AddUser(self, user):
        self._state.USERS.add(user)

    def DeleteUser(self, user):
        self._state.UR -= {(user, r) for r in self._state.ROLES}
        self._state.USERS.remove(user)

    def AddRole(self, role):
        self._state.ROLES.add(role)

    def DeleteRole(self, role):
        self._state.UR -= {(u, role) for u in self._state.USERS}
        self._state.PR -= {(p, role) for p in self._state.PERMS}
        self._state.ROLES.remove(role)

    def AddPerm(self, perm):
        self._state.PERMS.add(perm)

    def DeletePerm(self, perm):
        self._state.PR -= {(perm, r) for r in self._state.ROLES}
        self._state.PERMS.remove(perm)

    def AddUR(self, user, role):
        self._state.UR.add((user, role))

    def DeleteUR(self, user, role):
        self._state.UR.remove((user, role))

    def AddPR(self, perm, role):
        self._state.PR.add((perm, role))

    def DeletePR(self, perm, role):
        self._state.PR.remove((perm, role))

    def AssignedUsers(self, role):
        return {u for (u, _BoundPattern356_) in self._state.UR if (_BoundPattern356_ == role)}

    def AssignedRoles(self, user):
        return {r for (_BoundPattern367_, r) in self._state.UR if (_BoundPattern367_ == user)}

    def UserPermissions(self, user):
        return {p for (_BoundPattern380_, r) in self._state.UR if (_BoundPattern380_ == user) for (p, _FreePattern389_) in self._state.PR if (_FreePattern389_ == r)}

    def CheckAccess(self, user, perm):
        r = None

        def ExistentialOpExpr_398():
            nonlocal r
            for r in self._state.ROLES:
                if (((user, r) in self._state.UR) and ((perm, r) in self._state.PR)):
                    return True
            return False
        return ExistentialOpExpr_398()

class HierarchicalRBAC_set(CoreRBAC, da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([])

    def Trans(self, E):
        T = E
        y = x = z = None

        def ExistentialOpExpr_428():
            nonlocal y, x, z
            for (x, y) in T:
                for (_FreePattern439_, z) in E:
                    if (_FreePattern439_ == y):
                        if (not ((x, z) in T)):
                            return True
            return False
        while ExistentialOpExpr_428():
            T.add((x, z))
        return (T | {(r, r) for r in ROLES})

class HierarchicalRBAC_rules(CoreRBAC, da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([])

    def rules(self, name='Trans_rules'):
        if edge(x, y):
            path(x, y)
        if (edge(x, z) and path(z, y)):
            path(x, y)

    def Trans(self, E):
        return (infer(path, edge=E, rules=Trans_rules) | {(r, r) for r in ROLES})

class HierarchicalRBAC(HierarchicalRBAC_set, da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([])

    def setup(self, **rest_1360):
        super().setup(**rest_1360)
        self._state.RH = set()

    def AddInheritance(self, a, d):
        self._state.RH.add((a, d))

    def DeleteInheritance(self, a, d):
        self._state.RH.remove((a, d))

    def AuthorizedUsers(self, role):
        return {u for (u, asc) in UR for (_FreePattern591_, _BoundPattern592_) in Trans(self._state.RH) if (_FreePattern591_ == asc) if (_BoundPattern592_ == role)}

    def AuthorizedRoles(self, user):
        return {r for (_BoundPattern606_, asc) in UR if (_BoundPattern606_ == user) for (_FreePattern614_, r) in Trans(self._state.RH) if (_FreePattern614_ == asc)}

class CoreRBACwithSSD(CoreRBAC, da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([])

    def setup(self, **rest_1360):
        super().setup(**rest_1360)
        self._state.SsdNAMES = set()
        self._state.SsdNR = set()
        self._state.SsdNC = set()

    def constraint(self, name='SSD'):
        c = u = name = None

        def UniversalOpExpr_667():
            nonlocal c, u, name
            for u in USERS:
                for (name, c) in self._state.SsdNC:
                    if (not (countof(r, (r in AssignedRoles(u)), ((_name, r) in self._state.SsdNR)) <= c)):
                        return False
            return True
        return UniversalOpExpr_667()

    def CreateSsdSet(self, name, roles, c):
        self._state.SsdNAMES.add(name)
        self._state.SsdNR |= {(name, r) for r in roles}
        self._state.SsdNC.add((name, c))

    def DeleteSsdSet(self, name):
        self._state.SsdNR -= {(name, r) for r in self.SsdRoleSetRoles(name)}
        self._state.SsdNC.remove((name, self.SsdRoleSetCardinality(name)))
        self._state.SsdNAMES.remove(name)

    def AddSsdRoleMember(self, name, role):
        self._state.SsdNR.add((name, role))

    def DeleteSsdRoleMember(self, name, role):
        self._state.SsdNR.remove((name, role))

    def SetSsdSetCardinality(self, name, c):
        self._state.SsdNC.remove((name, self.SsdRoleSetCardinality(name)))
        self._state.SsdNC.add((name, c))

    def SsdRoleSets(self):
        return self._state.SsdNAMES

    def SsdRoleSetRoles(self, name):
        return {r for (_BoundPattern811_, r) in self._state.SsdNR if (_BoundPattern811_ == name)}

    def SsdRoleSetCardinality(self, name):
        return anyof(c, ((_name, c) in self._state.SsdNC))

class HierarchicalRBACwithSSD(HierarchicalRBAC, CoreRBACwithSSD, da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([])

    def constraint(self, name='SSD'):
        name = c = u = None

        def UniversalOpExpr_845():
            nonlocal name, c, u
            for u in USERS:
                for (name, c) in SsdNC:
                    if (not (countof(r, (r in AuthorizedRoles(u)), ((_name, r) in SsdNR)) <= c)):
                        return False
            return True
        return UniversalOpExpr_845()

class AdminRBAC(HierarchicalRBACwithSSD):
    "\n  Administrative RBAC for HierarchicalRBACwithSSD\n  has optimization and planning functions:\n\n    MineMinRoles:\n      find a smallest set of roles with UR' and PR' assignments\n      such that UR' * PR' = UR * PR\n\n    MineMinRoleAssignments:\n      find a smallest set of UR' and PR' assignments\n      such that UR' * PR' = UR * PR = UP\n\n    GetRolesPlan(user, roles, acts):\n      find a sequence of actions, i.e., updates, in acts that\n      allows user to get roles\n\n    GetRolesShortestPlan(user, roles, acts):\n      find a shortest sequence of actions, i.e., updates, in acts that\n      allows user to get roles\n\n  Any subset of updates can be used as acts. \n  All constraints must hold after each action.\n\n  The first two can have a version that includes finding RH'.\n\n  Administrative RBAC could also be for\n    CoreRBAC, HierarchicalRBAC, or CoreRBACwithSSD.\n  "

    def MineMinRoles():
        return anyof((R, UR2, PR2), (R in subset((ran(UR) & ran(PR)))), (UR2 in subset((dom(UR) * R))), (PR2 in subset((dom(PR) * R))), ((UR2 * PR2) == (UR * PR)), minimize=count(R))

    def MineMinRoleAssignments():
        return anyof((R, UR2, PR2), (R in subset((ran(UR) & ran(PR)))), (UR2 in subset((dom(UR) * R))), (PR2 in subset((dom(PR) * R))), ((UR2 * PR2) == (UR * PR)), minimize=count((UR2 + PR2)))

    def GetRolesPlan(user, roles, acts):
        assume(True)
        seq = []
        r = None

        def UniversalOpExpr_1022():
            nonlocal r
            for r in roles:
                if (not ((_user, r) in UR)):
                    return False
            return True
        while (not UniversalOpExpr_1022()):
            a = None

            def ExistentialOpExpr_1036():
                nonlocal a
                for a in instances(acts):
                    if True:
                        return True
                return False
            if ExistentialOpExpr_1036():
                do(a)
                seq.append(a)
        achieve(anyof(seq))

    def GetRolesShortestPlan(user, roles, acts):
        assume(True)
        seq = []
        cost = 0
        r = None

        def UniversalOpExpr_1085():
            nonlocal r
            for r in roles:
                if (not ((_user, r) in UR)):
                    return False
            return True
        while (not UniversalOpExpr_1085()):
            a = None

            def ExistentialOpExpr_1099():
                nonlocal a
                for a in instances(acts):
                    if True:
                        return True
                return False
            if ExistentialOpExpr_1099():
                do(a)
                seq.append(a)
                cost += 1
        achieve(anyof((seq, cost), minimize=cost))

class DistRBAC(HierarchicalRBACwithSSD, da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._DistRBACReceivedEvent_0 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_DistRBACReceivedEvent_0', PatternExpr_1233, sources=[PatternExpr_1240], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_DistRBACReceivedEvent_1', PatternExpr_1290, sources=[PatternExpr_1299], destinations=None, timestamps=None, record_history=None, handlers=[self._DistRBAC_handler_1289]), da.pat.EventPattern(da.pat.ReceivedEvent, '_DistRBACReceivedEvent_2', PatternExpr_1325, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._DistRBAC_handler_1324]), da.pat.EventPattern(da.pat.ReceivedEvent, '_DistRBACReceivedEvent_3', PatternExpr_1344, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._DistRBAC_handler_1343])])

    def setup(self, OTHERS, **rest_1360):
        super().setup(OTHERS=OTHERS, **rest_1360)
        self._state.OTHERS = OTHERS
        self._state.GuestR = set()

    def AddGuestRole(self, rbac, role, guest):
        self._state.GuestR.add(((rbac, role), guest))

    def DeleteGuestRole(self, rbac, role, guest):
        self._state.GuestR.remove(((rbac, role), guest))

    def GuestRoles(self, rbac, role):
        return {guest for ((_BoundPattern1192_, _BoundPattern1193_), guest) in self._state.GuestR if (_BoundPattern1192_ == rbac) if (_BoundPattern1193_ == role)}

    def OthersRoles(self, guest):
        return {(rbac, role) for ((rbac, role), _BoundPattern1212_) in self._state.GuestR if (_BoundPattern1212_ == guest)}

    def AddGuestUR(self, user, rbac, role):
        self.send(('credential', user, role), to=rbac)
        super()._label('_st_label_1230', block=False)
        _st_label_1230 = 0
        while (_st_label_1230 == 0):
            _st_label_1230 += 1
            if PatternExpr_1242.match_iter(self._DistRBACReceivedEvent_0, _BoundPattern1248_=rbac, _BoundPattern1252_=user, _BoundPattern1253_=role, SELF_ID=self._id):
                for r in self.GuestRoles(rbac, role):
                    AddUR(user, r)
                _st_label_1230 += 1
            else:
                super()._label('_st_label_1230', block=True)
                _st_label_1230 -= 1

    def DeleteGuestUR(self, user, rbac, role):
        for r in self.GuestRoles(rbac, role):
            DeleteUR(user, r)

    def _DistRBAC_handler_1289(self, user, role, rbac):
        if ((user, role) in UR):
            self.send(('accept', user, role), to=rbac)
        else:
            self.send(('reject', user, role), to=rbac)
    _DistRBAC_handler_1289._labels = None
    _DistRBAC_handler_1289._notlabels = None

    def _DistRBAC_handler_1324(self, user, rbac, role):
        self.AddGuestUR(user, rbac, role)
    _DistRBAC_handler_1324._labels = None
    _DistRBAC_handler_1324._notlabels = None

    def _DistRBAC_handler_1343(self, user, rbac, role):
        self.DeleteGuestUR(user, rbac, role)
    _DistRBAC_handler_1343._labels = None
    _DistRBAC_handler_1343._notlabels = None
