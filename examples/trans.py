# -*- generated by 1.0.12 -*-
import da
_config_object = {}

def if_(c):
    pass

def trans_rules():
    pass

def trans_left_rec_rules():
    pass

class Trans(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([])

    def setup(self, E, **rest_844):
        super().setup(E=E, **rest_844)
        self._state.E = E
        pass

    def run(self):
        print(self.trans(self._state.E))

    def trans(self, E):
        pass

    def infer(self, *args, rules={}, **kwargs):
        '\n    for input using keyword arguments:\n    if keyword arguments are given, use the given arguments as input,\n    otherwise if named attributes are defined, use defined attributes ?\n    otherwise, use empty sets ?  no, treat as undefined\n    for output using non-keyword arguments:\n    if non-keyward arguments are given, return a set of tuples for each arg,\n    otherwise, write to named attributes of the inferred sets of tuples\n    '
        pass

class Trans_py(Trans, da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([])

    def trans(self, E):
        T = E
        W = ({(x, d) for (x, y) in T for (a, d) in E if (y == a)} - T)
        while W:
            T.add(W.pop())
            W = ({(x, d) for (x, y) in T for (a, d) in E if (y == a)} - T)
        return T

class Trans_set(Trans, da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([])

    def trans(self, E):
        T = E
        y = x = z = None

        def ExistentialOpExpr_286():
            nonlocal y, x, z
            for (x, y) in T:
                for (_FreePattern297_, z) in E:
                    if (_FreePattern297_ == y):
                        if (not ((x, z) in T)):
                            return True
            return False
        while ExistentialOpExpr_286():
            T.add((x, z))
        return T

class Trans_rules(Trans, da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([])

    def rules(self, name=trans_rules, edge=['certain', (int, int)], path='certain'):
        (path(x, y), if_(edge(x, y)))
        (path(x, y), if_(edge(x, z), path(z, y)))

    def trans(self, E):
        return infer(path, rules=trans_rules, edge=E)

class Trans_left_rec_rules(Trans, da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([])

    def rules(self, name=trans_left_rec_rules):
        (path(x, y), if_(edge(x, y)))
        (path(x, y), if_(path(x, z), edge(z, y)))

    def trans(self, E):
        return infer(path, rules=trans_left_rec_rules, edge=E)
from gen import *

def gen_graph(v, e):
    '\n  generate a graph of v vertices and e edges\n  and write to a file\n  '
    D1 = Domain(1, v)
    R1 = Relation('edge', D1, D1)
    R1.Set_Rel_Size(e)
    DB1 = Database('testDB')
    DB1.Add_Relations(R1)
    DB1.Generate()
    R1.Distr_Constr4()
    R1.Avg_Constr4()
    R1.Max_Constr4()
    R1.Min_Constr4()
    DB1.SaveLiuPyGraph(((('v' + str(v)) + 'e') + str(e)))
from timeit import Timer

class Node_(da.NodeProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([])

    def run(self):
        esizes = []
        esizes += [(1000, e) for e in [2000, 4000, 6000, 8000, 10000]]
        vsizes = []
        vsizes += [(v, 10000) for v in [200, 400, 600, 800, 1000]]
        v1000e10000 = {('edge', (683, 441)), ('edge', (539, 632)), ('edge', (395, 67)), ('edge', (475, 864)), ('edge', (609, 278)), ('edge', (177, 675)), ('edge', (296, 786)), ('edge', (626, 843)), ('edge', (615, 242)), ('edge', (671, 640)), ('edge', (258, 28)), ('edge', (206, 670)), ('edge', (37, 739)), ('edge', (878, 485)), ('edge', (958, 294)), ('edge', (940, 246)), ('edge', (998, 154)), ('edge', (664, 890)), ('edge', (681, 710)), ('edge', (477, 380)), ('edge', (407, 526)), ('edge', (339, 624)), ('edge', (968, 225)), ('edge', (915, 368)), ('edge', (750, 834)), ('edge', (365, 615)), ('edge', (538, 335)), ('edge', (635, 97)), ('edge', (636, 810)), ('edge', (757, 339)), ('edge', (410, 494)), ('edge', (371, 232)), ('edge', (748, 606)), ('edge', (245, 524)), ('edge', (324, 389)), ('edge', (549, 482)), ('edge', (229, 966)), ('edge', (732, 689)), ('edge', (363, 874)), ('edge', (279, 957)), ('edge', (223, 179)), ('edge', (529, 70)), ('edge', (175, 772)), ('edge', (814, 282)), ('edge', (83, 229)), ('edge', (72, 927)), ('edge', (343, 848)), ('edge', (16, 842)), ('edge', (843, 722)), ('edge', (610, 449)), ('edge', (605, 509)), ('edge', (647, 226)), ('edge', (893, 858))}
        o3 = self.new(Trans_rules, [v1000e10000])
        o4 = self.new(Trans_left_rec_rules, [v1000e10000])
        self._start(o3)
        self._start(o4)
