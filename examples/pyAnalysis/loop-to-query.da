import os, sys, ast, shutil
from da.compiler.utils import to_source
from analyzer import Analyzer

class LoopTansformer(ast.NodeTransformer):
	
	def __init__(self,transDict):
		super().__init__()
		self.transDict = transDict

	def visit_For(self,node):
		if node in self.transDict:
			return self.transDict[node]
		else:
			return self.generic_visit(node)

VariableDict = dict()
class GetVariable(ast.NodeVisitor):
	
	def generic_visit(self, node):
		"""Called if no explicit visitor function exists for a node."""
		if node in VariableDict:
			return VariableDict[node]

		result = set()
		for field, value in ast.iter_fields(node):
			if isinstance(value, list):
				for item in value:
					if isinstance(item, ast.AST):
						result |= self.visit(item)
			elif isinstance(value, ast.AST):
				result |= self.visit(value)

		VariableDict[node] = result
		return result

	def visit_Name(self, node):
		return {node.id}

class LoopAnalyzer(Analyzer):

	def query_candidate_rule(self):
		candidate = infer(rule=self.rules_compCandidate, queries=['compCandidate'])
		print('-------- number of candidate transformable loops:', len(candidate))
		for c in candidate:
			node = self.ValueDict[c]
			print('========== %s: lineno: %s ==========%s' % (self.ValueDict[self.FileDict[c]], node.lineno, to_source(node)))

	def rules_compCandidate():
		# 1. r.append(y), r.add(y)
		IncPattern(exprid),if_(Expr(exprid, bodyval),
			Call(bodyval,funcid,argid,_), Attribute(funcid,_,_,_),
			ListLen(argid,1))
		# 2. augAssign: r += y, r -= y
		IncPattern(aaid),if_(AugAssign(aaid,_,_,_))
		# 3. index assign: r[x] = y
		IncPattern(aid), if_(Assign(aid, tarlistid,_), 
			Member(tarlistid, resultid, _), Subscript(resultid,_,keyid,_))
		# 4.1 if-else expr with IncPattern body and orbody
		IncPattern(ifid), if_(
			If(ifid,_, bodyid, orbodyid),
			ListLen(bodyid,1), 
			Member(bodyid,body,_), IncPattern(body),
			ListLen(orbodyid,1), 
			Member(orbodyid,orbody,_), IncPattern(orbody))
		# 4.2 if expr with IncPattern body
		IncPattern(ifid), if_(
			If(ifid,_, bodyid, orbody),
			ListLen(bodyid,1), 
			Member(bodyid, body,_), IncPattern(body),
			ListLen(orbody,0))
		# 5. for-loops with IncPattern body
		IncPattern(forid), if_(
			For(forid,_,_, bodyid,_),
			ListLen(bodyid,1), 
			Member(bodyid, body,_), IncPattern(body))

		compCandidate(id), if_(For(id,_,_,_,_), IncPattern(id))

	def flattenTuple(self, node):
		if isinstance(node, ast.Name):
			return [node.id]
		if isinstance(node, ast.Tuple):
			return sum([self.flattenTuple(t) for t in node.elts],[])

	def rules_simplestComp():
		# r.append(x), r.add(x)
		ListSetAdd(exprid, result, elt, operator),if_(
			Expr(exprid, bodyvalue), Call(bodyvalue, funcid, argid,_),
			Attribute(funcid, result, operator, _), Name(result,_,_),
			Member(argid, elt,_), ListLen(argid,1))

		compFor(forid, target, itr, result, elt, operator), if_(
			For(forid, target, itr, bodyid, _),
			ListLen(bodyid, 1), Member(bodyid, body, _), 
			ListSetAdd(body,result, elt, operator), AllowedOp(operator))

	def query_forToCompSimple_rule(self):
		candidate = infer(rule=self.rules_simplestComp, 
						  bindings=[('AllowedOp', {self.ValueIdDict['add'], self.ValueIdDict['append']})],
						  queries=['compFor'])
		iterNameDict = {c[0]:self.flattenTuple(self.ValueDict[c[1]]) for c in candidate}
		transDict = dict()
		# to comprehension: result = operator(elt for target in iterable)
		varVisitor = GetVariable()
		for forid, target, itr, result, elt, operator in candidate:
			fileid = self.FileDict[forid]
			if self.ValueDict[result].id in iterNameDict[forid]:
				continue
			op = self.ValueDict[operator]
			forast = self.ValueDict[forid]
			# check dependencies: 1. result independent to target, 2. elt independent to result
			resultVars = varVisitor.visit(self.ValueDict[result])
			targetVars = varVisitor.visit(self.ValueDict[target])
			eltVars = varVisitor.visit(self.ValueDict[elt])
			# print(resultVars, targetVars, eltVars)
			if targetVars.intersection(resultVars) or resultVars.intersection(eltVars):
				continue
			if isinstance(op,str):
				if op == 'append':
					comp = ast.ListComp
					augop = ast.Add()
				elif op == 'add':
					comp = ast.SetComp
					augop = ast.BitOr()
				else:
					print('!!!!!! unexpected operator',op)
					continue
				compAst = ast.AugAssign([self.ValueDict[result]], augop,
									 comp(self.ValueDict[elt], 
									 	  [ast.comprehension(self.ValueDict[target], self.ValueDict[itr], [], 0)]))
				if fileid not in transDict:
					transDict[fileid] = dict()
				transDict[fileid][forast] = compAst

		for file, innerDict in transDict.items():
			for key, val in sorted(innerDict.items(), key=lambda t: t[0].lineno):
				print('========== %s: lineno: %s ==========%s----------- transformed to ------------%s' 
						% (self.ValueDict[file], key.lineno, to_source(key), to_source(val)))

		self.write_transformed(transDict)

	def write_transformed(self, transDict):
		outFolder = os.path.join('output','LoopToQuery')
		basename = os.path.basename(self.filename)
		outroot = os.path.join(outFolder,basename)
		if os.path.exists(outroot):
			shutil.rmtree(outroot)
		for m in self.Module:
			fileid = self.FileDict[m[0]]
			file = self.ValueDict[fileid]
			outdir = os.path.join(outFolder, os.path.dirname(file))
			os.makedirs(outdir, exist_ok=True)
			outfile = os.path.join(outdir, os.path.basename(file)+'.py')
			
			if fileid in transDict:
				cr = LoopTansformer(transDict[fileid]).visit(self.ValueDict[m[0]])
				txt =to_source(cr)
			else:
				txt = to_source(self.ValueDict[m[0]])
			open(outfile,'w').write(txt)
