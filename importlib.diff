diff --git a/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__init__.py b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__init__.py
index cb37d24..0c73c50 100644
--- a/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__init__.py
+++ b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__init__.py
@@ -48,8 +48,8 @@
     sys.modules['importlib._bootstrap_external'] = _bootstrap_external
 
 # To simplify imports in test code
-_w_long = _bootstrap_external._w_long
-_r_long = _bootstrap_external._r_long
+_pack_uint32 = _bootstrap_external._pack_uint32
+_unpack_uint32 = _bootstrap_external._unpack_uint32
 
 # Fully bootstrapped at this point, import whatever you like, circular
 # dependencies and startup overhead minimisation permitting :)
diff --git a/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/__init__.cpython-37.opt-1.pyc b/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/__init__.cpython-37.opt-1.pyc
deleted file mode 100644
index 023270c..0000000
Binary files a/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/__init__.cpython-37.opt-1.pyc and /dev/null differ
diff --git a/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/__init__.cpython-37.opt-2.pyc b/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/__init__.cpython-37.opt-2.pyc
deleted file mode 100644
index fce1626..0000000
Binary files a/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/__init__.cpython-37.opt-2.pyc and /dev/null differ
diff --git a/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/__init__.cpython-37.pyc b/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/__init__.cpython-37.pyc
deleted file mode 100644
index 023270c..0000000
Binary files a/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/__init__.cpython-37.pyc and /dev/null differ
diff --git a/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/__init__.cpython-39.opt-1.pyc b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/__init__.cpython-39.opt-1.pyc
new file mode 100644
index 0000000..f7f3d60
Binary files /dev/null and b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/__init__.cpython-39.opt-1.pyc differ
diff --git a/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/__init__.cpython-39.opt-2.pyc b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/__init__.cpython-39.opt-2.pyc
new file mode 100644
index 0000000..825a7a8
Binary files /dev/null and b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/__init__.cpython-39.opt-2.pyc differ
diff --git a/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/__init__.cpython-39.pyc b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/__init__.cpython-39.pyc
new file mode 100644
index 0000000..f7f3d60
Binary files /dev/null and b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/__init__.cpython-39.pyc differ
diff --git a/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/_bootstrap.cpython-37.opt-1.pyc b/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/_bootstrap.cpython-37.opt-1.pyc
deleted file mode 100644
index 622d06c..0000000
Binary files a/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/_bootstrap.cpython-37.opt-1.pyc and /dev/null differ
diff --git a/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/_bootstrap.cpython-37.opt-2.pyc b/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/_bootstrap.cpython-37.opt-2.pyc
deleted file mode 100644
index 3e91eb1..0000000
Binary files a/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/_bootstrap.cpython-37.opt-2.pyc and /dev/null differ
diff --git a/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/_bootstrap.cpython-37.pyc b/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/_bootstrap.cpython-37.pyc
deleted file mode 100644
index 203d4a6..0000000
Binary files a/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/_bootstrap.cpython-37.pyc and /dev/null differ
diff --git a/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/_bootstrap.cpython-39.opt-1.pyc b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/_bootstrap.cpython-39.opt-1.pyc
new file mode 100644
index 0000000..3deb50a
Binary files /dev/null and b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/_bootstrap.cpython-39.opt-1.pyc differ
diff --git a/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/_bootstrap.cpython-39.opt-2.pyc b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/_bootstrap.cpython-39.opt-2.pyc
new file mode 100644
index 0000000..97432ce
Binary files /dev/null and b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/_bootstrap.cpython-39.opt-2.pyc differ
diff --git a/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/_bootstrap.cpython-39.pyc b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/_bootstrap.cpython-39.pyc
new file mode 100644
index 0000000..6b21de8
Binary files /dev/null and b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/_bootstrap.cpython-39.pyc differ
diff --git a/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/_bootstrap_external.cpython-37.opt-1.pyc b/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/_bootstrap_external.cpython-37.opt-1.pyc
deleted file mode 100644
index 59e2fdc..0000000
Binary files a/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/_bootstrap_external.cpython-37.opt-1.pyc and /dev/null differ
diff --git a/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/_bootstrap_external.cpython-37.opt-2.pyc b/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/_bootstrap_external.cpython-37.opt-2.pyc
deleted file mode 100644
index 36a49e5..0000000
Binary files a/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/_bootstrap_external.cpython-37.opt-2.pyc and /dev/null differ
diff --git a/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/_bootstrap_external.cpython-37.pyc b/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/_bootstrap_external.cpython-37.pyc
deleted file mode 100644
index 515e1d0..0000000
Binary files a/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/_bootstrap_external.cpython-37.pyc and /dev/null differ
diff --git a/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/_bootstrap_external.cpython-39.opt-1.pyc b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/_bootstrap_external.cpython-39.opt-1.pyc
new file mode 100644
index 0000000..cf18ce1
Binary files /dev/null and b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/_bootstrap_external.cpython-39.opt-1.pyc differ
diff --git a/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/_bootstrap_external.cpython-39.opt-2.pyc b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/_bootstrap_external.cpython-39.opt-2.pyc
new file mode 100644
index 0000000..52f0039
Binary files /dev/null and b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/_bootstrap_external.cpython-39.opt-2.pyc differ
diff --git a/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/_bootstrap_external.cpython-39.pyc b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/_bootstrap_external.cpython-39.pyc
new file mode 100644
index 0000000..3748d0f
Binary files /dev/null and b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/_bootstrap_external.cpython-39.pyc differ
diff --git a/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/_common.cpython-39.opt-1.pyc b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/_common.cpython-39.opt-1.pyc
new file mode 100644
index 0000000..f5638d3
Binary files /dev/null and b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/_common.cpython-39.opt-1.pyc differ
diff --git a/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/_common.cpython-39.opt-2.pyc b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/_common.cpython-39.opt-2.pyc
new file mode 100644
index 0000000..4a785a3
Binary files /dev/null and b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/_common.cpython-39.opt-2.pyc differ
diff --git a/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/_common.cpython-39.pyc b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/_common.cpython-39.pyc
new file mode 100644
index 0000000..f5638d3
Binary files /dev/null and b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/_common.cpython-39.pyc differ
diff --git a/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/abc.cpython-37.opt-1.pyc b/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/abc.cpython-37.opt-1.pyc
deleted file mode 100644
index f46f751..0000000
Binary files a/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/abc.cpython-37.opt-1.pyc and /dev/null differ
diff --git a/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/abc.cpython-37.opt-2.pyc b/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/abc.cpython-37.opt-2.pyc
deleted file mode 100644
index 99d65bc..0000000
Binary files a/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/abc.cpython-37.opt-2.pyc and /dev/null differ
diff --git a/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/abc.cpython-37.pyc b/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/abc.cpython-37.pyc
deleted file mode 100644
index f46f751..0000000
Binary files a/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/abc.cpython-37.pyc and /dev/null differ
diff --git a/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/abc.cpython-39.opt-1.pyc b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/abc.cpython-39.opt-1.pyc
new file mode 100644
index 0000000..d14fe3c
Binary files /dev/null and b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/abc.cpython-39.opt-1.pyc differ
diff --git a/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/abc.cpython-39.opt-2.pyc b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/abc.cpython-39.opt-2.pyc
new file mode 100644
index 0000000..850fa52
Binary files /dev/null and b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/abc.cpython-39.opt-2.pyc differ
diff --git a/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/abc.cpython-39.pyc b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/abc.cpython-39.pyc
new file mode 100644
index 0000000..d14fe3c
Binary files /dev/null and b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/abc.cpython-39.pyc differ
diff --git a/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/machinery.cpython-37.opt-1.pyc b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/machinery.cpython-39.opt-1.pyc
similarity index 56%
rename from /Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/machinery.cpython-37.opt-1.pyc
rename to /Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/machinery.cpython-39.opt-1.pyc
index 679f1fc..3489bc9 100644
Binary files a/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/machinery.cpython-37.opt-1.pyc and b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/machinery.cpython-39.opt-1.pyc differ
diff --git a/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/machinery.cpython-37.opt-2.pyc b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/machinery.cpython-39.opt-2.pyc
similarity index 58%
rename from /Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/machinery.cpython-37.opt-2.pyc
rename to /Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/machinery.cpython-39.opt-2.pyc
index 45fde50..d06243a 100644
Binary files a/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/machinery.cpython-37.opt-2.pyc and b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/machinery.cpython-39.opt-2.pyc differ
diff --git a/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/machinery.cpython-37.pyc b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/machinery.cpython-39.pyc
similarity index 56%
rename from /Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/machinery.cpython-37.pyc
rename to /Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/machinery.cpython-39.pyc
index 679f1fc..3489bc9 100644
Binary files a/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/machinery.cpython-37.pyc and b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/machinery.cpython-39.pyc differ
diff --git a/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/metadata.cpython-39.opt-1.pyc b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/metadata.cpython-39.opt-1.pyc
new file mode 100644
index 0000000..3eee328
Binary files /dev/null and b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/metadata.cpython-39.opt-1.pyc differ
diff --git a/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/metadata.cpython-39.opt-2.pyc b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/metadata.cpython-39.opt-2.pyc
new file mode 100644
index 0000000..644069b
Binary files /dev/null and b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/metadata.cpython-39.opt-2.pyc differ
diff --git a/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/metadata.cpython-39.pyc b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/metadata.cpython-39.pyc
new file mode 100644
index 0000000..3eee328
Binary files /dev/null and b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/metadata.cpython-39.pyc differ
diff --git a/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/resources.cpython-37.opt-1.pyc b/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/resources.cpython-37.opt-1.pyc
deleted file mode 100644
index ca39a8e..0000000
Binary files a/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/resources.cpython-37.opt-1.pyc and /dev/null differ
diff --git a/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/resources.cpython-37.opt-2.pyc b/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/resources.cpython-37.opt-2.pyc
deleted file mode 100644
index e089999..0000000
Binary files a/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/resources.cpython-37.opt-2.pyc and /dev/null differ
diff --git a/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/resources.cpython-37.pyc b/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/resources.cpython-37.pyc
deleted file mode 100644
index a0ac4d3..0000000
Binary files a/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/resources.cpython-37.pyc and /dev/null differ
diff --git a/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/resources.cpython-39.opt-1.pyc b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/resources.cpython-39.opt-1.pyc
new file mode 100644
index 0000000..cde4051
Binary files /dev/null and b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/resources.cpython-39.opt-1.pyc differ
diff --git a/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/resources.cpython-39.opt-2.pyc b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/resources.cpython-39.opt-2.pyc
new file mode 100644
index 0000000..03784ff
Binary files /dev/null and b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/resources.cpython-39.opt-2.pyc differ
diff --git a/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/resources.cpython-39.pyc b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/resources.cpython-39.pyc
new file mode 100644
index 0000000..cde4051
Binary files /dev/null and b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/resources.cpython-39.pyc differ
diff --git a/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/util.cpython-37.opt-1.pyc b/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/util.cpython-37.opt-1.pyc
deleted file mode 100644
index d22b94e..0000000
Binary files a/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/util.cpython-37.opt-1.pyc and /dev/null differ
diff --git a/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/util.cpython-37.opt-2.pyc b/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/util.cpython-37.opt-2.pyc
deleted file mode 100644
index b1cacac..0000000
Binary files a/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/util.cpython-37.opt-2.pyc and /dev/null differ
diff --git a/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/util.cpython-37.pyc b/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/util.cpython-37.pyc
deleted file mode 100644
index d22b94e..0000000
Binary files a/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/__pycache__/util.cpython-37.pyc and /dev/null differ
diff --git a/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/util.cpython-39.opt-1.pyc b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/util.cpython-39.opt-1.pyc
new file mode 100644
index 0000000..a1985e6
Binary files /dev/null and b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/util.cpython-39.opt-1.pyc differ
diff --git a/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/util.cpython-39.opt-2.pyc b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/util.cpython-39.opt-2.pyc
new file mode 100644
index 0000000..1a205d9
Binary files /dev/null and b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/util.cpython-39.opt-2.pyc differ
diff --git a/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/util.cpython-39.pyc b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/util.cpython-39.pyc
new file mode 100644
index 0000000..a1985e6
Binary files /dev/null and b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/__pycache__/util.cpython-39.pyc differ
diff --git a/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/_bootstrap.py b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/_bootstrap.py
index 2bdd192..e00b27e 100644
--- a/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/_bootstrap.py
+++ b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/_bootstrap.py
@@ -7,9 +7,9 @@
 
 """
 #
-# IMPORTANT: Whenever making changes to this module, be sure to run
-# a top-level make in order to get the frozen version of the module
-# updated. Not doing so will result in the Makefile to fail for
+# IMPORTANT: Whenever making changes to this module, be sure to run a top-level
+# `make regen-importlib` followed by `make` in order to get the frozen version
+# of the module updated. Not doing so will result in the Makefile to fail for
 # all others who don't have a ./python around to freeze the module
 # in the early stages of compilation.
 #
@@ -67,6 +67,7 @@ def has_deadlock(self):
         # Deadlock avoidance for concurrent circular imports.
         me = _thread.get_ident()
         tid = self.owner
+        seen = set()
         while True:
             lock = _blocking_on.get(tid)
             if lock is None:
@@ -74,6 +75,14 @@ def has_deadlock(self):
             tid = lock.owner
             if tid == me:
                 return True
+            if tid in seen:
+                # bpo 38091: the chain of tid's we encounter here
+                # eventually leads to a fixpoint or a cycle, but
+                # does not reach 'me'.  This means we would not
+                # actually deadlock.  This can happen if other
+                # threads are at the beginning of acquire() below.
+                return False
+            seen.add(tid)
 
     def acquire(self):
         """
@@ -302,33 +311,6 @@ def _module_repr(module):
         return '<module {!r} from {!r}>'.format(name, filename)
 
 
-class _installed_safely:
-
-    def __init__(self, module):
-        self._module = module
-        self._spec = module.__spec__
-
-    def __enter__(self):
-        # This must be done before putting the module in sys.modules
-        # (otherwise an optimization shortcut in import.c becomes
-        # wrong)
-        self._spec._initializing = True
-        sys.modules[self._spec.name] = self._module
-
-    def __exit__(self, *args):
-        try:
-            spec = self._spec
-            if any(arg is not None for arg in args):
-                try:
-                    del sys.modules[spec.name]
-                except KeyError:
-                    pass
-            else:
-                _verbose_message('import {!r} # {!r}', spec.name, spec.loader)
-        finally:
-            self._spec._initializing = False
-
-
 class ModuleSpec:
     """The specification for a module, used for loading.
 
@@ -398,7 +380,7 @@ def __eq__(self, other):
                     self.cached == other.cached and
                     self.has_location == other.has_location)
         except AttributeError:
-            return False
+            return NotImplemented
 
     @property
     def cached(self):
@@ -614,30 +596,44 @@ def _exec(spec, module):
         if sys.modules.get(name) is not module:
             msg = 'module {!r} not in sys.modules'.format(name)
             raise ImportError(msg, name=name)
-        if spec.loader is None:
-            if spec.submodule_search_locations is None:
-                raise ImportError('missing loader', name=spec.name)
-            # namespace package
-            _init_module_attrs(spec, module, override=True)
-            return module
-        _init_module_attrs(spec, module, override=True)
-        if not hasattr(spec.loader, 'exec_module'):
-            # (issue19713) Once BuiltinImporter and ExtensionFileLoader
-            # have exec_module() implemented, we can add a deprecation
-            # warning here.
-            spec.loader.load_module(name)
-        else:
-            spec.loader.exec_module(module)
-    return sys.modules[name]
+        try:
+            if spec.loader is None:
+                if spec.submodule_search_locations is None:
+                    raise ImportError('missing loader', name=spec.name)
+                # Namespace package.
+                _init_module_attrs(spec, module, override=True)
+            else:
+                _init_module_attrs(spec, module, override=True)
+                if not hasattr(spec.loader, 'exec_module'):
+                    # (issue19713) Once BuiltinImporter and ExtensionFileLoader
+                    # have exec_module() implemented, we can add a deprecation
+                    # warning here.
+                    spec.loader.load_module(name)
+                else:
+                    spec.loader.exec_module(module)
+        finally:
+            # Update the order of insertion into sys.modules for module
+            # clean-up at shutdown.
+            module = sys.modules.pop(spec.name)
+            sys.modules[spec.name] = module
+    return module
 
 
 def _load_backward_compatible(spec):
     # (issue19713) Once BuiltinImporter and ExtensionFileLoader
     # have exec_module() implemented, we can add a deprecation
     # warning here.
-    spec.loader.load_module(spec.name)
+    try:
+        spec.loader.load_module(spec.name)
+    except:
+        if spec.name in sys.modules:
+            module = sys.modules.pop(spec.name)
+            sys.modules[spec.name] = module
+        raise
     # The module must be in sys.modules at this point!
-    module = sys.modules[spec.name]
+    # Move it to the end of sys.modules.
+    module = sys.modules.pop(spec.name)
+    sys.modules[spec.name] = module
     if getattr(module, '__loader__', None) is None:
         try:
             module.__loader__ = spec.loader
@@ -663,23 +659,42 @@ def _load_backward_compatible(spec):
 def _load_unlocked(spec):
     # A helper for direct use by the import system.
     if spec.loader is not None:
-        # not a namespace package
+        # Not a namespace package.
         if not hasattr(spec.loader, 'exec_module'):
             return _load_backward_compatible(spec)
 
     module = module_from_spec(spec)
-    with _installed_safely(module):
-        if spec.loader is None:
-            if spec.submodule_search_locations is None:
-                raise ImportError('missing loader', name=spec.name)
-            # A namespace package so do nothing.
-        else:
-            spec.loader.exec_module(module)
 
-    # We don't ensure that the import-related module attributes get
-    # set in the sys.modules replacement case.  Such modules are on
-    # their own.
-    return sys.modules[spec.name]
+    # This must be done before putting the module in sys.modules
+    # (otherwise an optimization shortcut in import.c becomes
+    # wrong).
+    spec._initializing = True
+    try:
+        sys.modules[spec.name] = module
+        try:
+            if spec.loader is None:
+                if spec.submodule_search_locations is None:
+                    raise ImportError('missing loader', name=spec.name)
+                # A namespace package so do nothing.
+            else:
+                spec.loader.exec_module(module)
+        except:
+            try:
+                del sys.modules[spec.name]
+            except KeyError:
+                pass
+            raise
+        # Move the module to the end of sys.modules.
+        # We don't ensure that the import-related module attributes get
+        # set in the sys.modules replacement case.  Such modules are on
+        # their own.
+        module = sys.modules.pop(spec.name)
+        sys.modules[spec.name] = module
+        _verbose_message('import {!r} # {!r}', spec.name, spec.loader)
+    finally:
+        spec._initializing = False
+
+    return module
 
 # A method used during testing of _load_unlocked() and by
 # _load_module_shim().
@@ -707,6 +722,8 @@ class BuiltinImporter:
 
     """
 
+    _ORIGIN = "built-in"
+
     @staticmethod
     def module_repr(module):
         """Return repr for the module.
@@ -714,14 +731,14 @@ def module_repr(module):
         The method is deprecated.  The import machinery does the job itself.
 
         """
-        return '<module {!r} (built-in)>'.format(module.__name__)
+        return f'<module {module.__name__!r} ({BuiltinImporter._ORIGIN})>'
 
     @classmethod
     def find_spec(cls, fullname, path=None, target=None):
         if path is not None:
             return None
         if _imp.is_builtin(fullname):
-            return spec_from_loader(fullname, cls, origin='built-in')
+            return spec_from_loader(fullname, cls, origin=cls._ORIGIN)
         else:
             return None
 
@@ -780,6 +797,8 @@ class FrozenImporter:
 
     """
 
+    _ORIGIN = "frozen"
+
     @staticmethod
     def module_repr(m):
         """Return repr for the module.
@@ -787,12 +806,12 @@ def module_repr(m):
         The method is deprecated.  The import machinery does the job itself.
 
         """
-        return '<module {!r} (frozen)>'.format(m.__name__)
+        return '<module {!r} ({})>'.format(m.__name__, FrozenImporter._ORIGIN)
 
     @classmethod
     def find_spec(cls, fullname, path=None, target=None):
         if _imp.is_frozen(fullname):
-            return spec_from_loader(fullname, cls, origin='frozen')
+            return spec_from_loader(fullname, cls, origin=cls._ORIGIN)
         else:
             return None
 
@@ -865,7 +884,7 @@ def _resolve_name(name, package, level):
     """Resolve a relative module name to an absolute one."""
     bits = package.rsplit('.', level - 1)
     if len(bits) < level:
-        raise ValueError('attempted relative import beyond top-level package')
+        raise ImportError('attempted relative import beyond top-level package')
     base = bits[0]
     return '{}.{}'.format(base, name) if name else base
 
@@ -968,7 +987,12 @@ def _find_and_load_unlocked(name, import_):
     if parent:
         # Set the module as an attribute on its parent.
         parent_module = sys.modules[parent]
-        setattr(parent_module, name.rpartition('.')[2], module)
+        child = name.rpartition('.')[2]
+        try:
+            setattr(parent_module, child, module)
+        except AttributeError:
+            msg = f"Cannot set an attribute on {parent!r} for child module {child!r}"
+            _warnings.warn(msg, ImportWarning)
     return module
 
 
@@ -1016,31 +1040,30 @@ def _handle_fromlist(module, fromlist, import_, *, recursive=False):
     """
     # The hell that is fromlist ...
     # If a package was imported, try to import stuff from fromlist.
-    if hasattr(module, '__path__'):
-        for x in fromlist:
-            if not isinstance(x, str):
-                if recursive:
-                    where = module.__name__ + '.__all__'
-                else:
-                    where = "``from list''"
-                raise TypeError(f"Item in {where} must be str, "
-                                f"not {type(x).__name__}")
-            elif x == '*':
-                if not recursive and hasattr(module, '__all__'):
-                    _handle_fromlist(module, module.__all__, import_,
-                                     recursive=True)
-            elif not hasattr(module, x):
-                from_name = '{}.{}'.format(module.__name__, x)
-                try:
-                    _call_with_frames_removed(import_, from_name)
-                except ModuleNotFoundError as exc:
-                    # Backwards-compatibility dictates we ignore failed
-                    # imports triggered by fromlist for modules that don't
-                    # exist.
-                    if (exc.name == from_name and
-                        sys.modules.get(from_name, _NEEDS_LOADING) is not None):
-                        continue
-                    raise
+    for x in fromlist:
+        if not isinstance(x, str):
+            if recursive:
+                where = module.__name__ + '.__all__'
+            else:
+                where = "``from list''"
+            raise TypeError(f"Item in {where} must be str, "
+                            f"not {type(x).__name__}")
+        elif x == '*':
+            if not recursive and hasattr(module, '__all__'):
+                _handle_fromlist(module, module.__all__, import_,
+                                 recursive=True)
+        elif not hasattr(module, x):
+            from_name = '{}.{}'.format(module.__name__, x)
+            try:
+                _call_with_frames_removed(import_, from_name)
+            except ModuleNotFoundError as exc:
+                # Backwards-compatibility dictates we ignore failed
+                # imports triggered by fromlist for modules that don't
+                # exist.
+                if (exc.name == from_name and
+                    sys.modules.get(from_name, _NEEDS_LOADING) is not None):
+                    continue
+                raise
     return module
 
 
@@ -1102,8 +1125,10 @@ def __import__(name, globals=None, locals=None, fromlist=(), level=0):
             # Slice end needs to be positive to alleviate need to special-case
             # when ``'.' not in name``.
             return sys.modules[module.__name__[:len(module.__name__)-cut_off]]
-    else:
+    elif hasattr(module, '__path__'):
         return _handle_fromlist(module, fromlist, _gcd_import)
+    else:
+        return module
 
 
 def _builtin_from_name(name):
diff --git a/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/_bootstrap_external.py b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/_bootstrap_external.py
index 66a16a6..7c41573 100644
--- a/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/_bootstrap_external.py
+++ b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/_bootstrap_external.py
@@ -19,6 +19,34 @@
 # reference any injected objects! This includes not only global code but also
 # anything specified at the class level.
 
+# Import builtin modules
+import _imp
+import _io
+import sys
+import _warnings
+import marshal
+
+
+_MS_WINDOWS = (sys.platform == 'win32')
+if _MS_WINDOWS:
+    import nt as _os
+    import winreg
+else:
+    import posix as _os
+
+
+if _MS_WINDOWS:
+    path_separators = ['\\', '/']
+else:
+    path_separators = ['/']
+# Assumption made in _path_join()
+assert all(len(sep) == 1 for sep in path_separators)
+path_sep = path_separators[0]
+path_sep_tuple = tuple(path_separators)
+path_separators = ''.join(path_separators)
+_pathseps_with_colon = {f':{s}' for s in path_separators}
+
+
 # Bootstrap-related code ######################################################
 _CASE_INSENSITIVE_PLATFORMS_STR_KEY = 'win',
 _CASE_INSENSITIVE_PLATFORMS_BYTES_KEY = 'cygwin', 'darwin'
@@ -34,8 +62,8 @@ def _make_relax_case():
             key = b'PYTHONCASEOK'
 
         def _relax_case():
-            """True if filenames must be checked case-insensitively."""
-            return key in _os.environ
+            """True if filenames must be checked case-insensitively and ignore environment flags are not set."""
+            return not sys.flags.ignore_environment and key in _os.environ
     else:
         def _relax_case():
             """True if filenames must be checked case-insensitively."""
@@ -43,32 +71,65 @@ def _relax_case():
     return _relax_case
 
 
-def _w_long(x):
+def _pack_uint32(x):
     """Convert a 32-bit integer to little-endian."""
     return (int(x) & 0xFFFFFFFF).to_bytes(4, 'little')
 
 
-def _r_long(int_bytes):
+def _unpack_uint32(data):
     """Convert 4 bytes in little-endian to an integer."""
-    return int.from_bytes(int_bytes, 'little')
-
+    assert len(data) == 4
+    return int.from_bytes(data, 'little')
+
+def _unpack_uint16(data):
+    """Convert 2 bytes in little-endian to an integer."""
+    assert len(data) == 2
+    return int.from_bytes(data, 'little')
+
+
+if _MS_WINDOWS:
+    def _path_join(*path_parts):
+        """Replacement for os.path.join()."""
+        if not path_parts:
+            return ""
+        if len(path_parts) == 1:
+            return path_parts[0]
+        root = ""
+        path = []
+        for new_root, tail in map(_os._path_splitroot, path_parts):
+            if new_root.startswith(path_sep_tuple) or new_root.endswith(path_sep_tuple):
+                root = new_root.rstrip(path_separators) or root
+                path = [path_sep + tail]
+            elif new_root.endswith(':'):
+                if root.casefold() != new_root.casefold():
+                    # Drive relative paths have to be resolved by the OS, so we reset the
+                    # tail but do not add a path_sep prefix.
+                    root = new_root
+                    path = [tail]
+                else:
+                    path.append(tail)
+            else:
+                root = new_root or root
+                path.append(tail)
+        path = [p.rstrip(path_separators) for p in path if p]
+        if len(path) == 1 and not path[0]:
+            # Avoid losing the root's trailing separator when joining with nothing
+            return root + path_sep
+        return root + path_sep.join(path)
 
-def _path_join(*path_parts):
-    """Replacement for os.path.join()."""
-    return path_sep.join([part.rstrip(path_separators)
-                          for part in path_parts if part])
+else:
+    def _path_join(*path_parts):
+        """Replacement for os.path.join()."""
+        return path_sep.join([part.rstrip(path_separators)
+                              for part in path_parts if part])
 
 
 def _path_split(path):
     """Replacement for os.path.split()."""
-    if len(path_separators) == 1:
-        front, _, tail = path.rpartition(path_sep)
-        return front, tail
-    for x in reversed(path):
-        if x in path_separators:
-            front, tail = path.rsplit(x, maxsplit=1)
-            return front, tail
-    return '', path
+    i = max(path.rfind(p) for p in path_separators)
+    if i < 0:
+        return '', path
+    return path[:i], path[i + 1:]
 
 
 def _path_stat(path):
@@ -102,6 +163,20 @@ def _path_isdir(path):
     return _path_is_mode_type(path, 0o040000)
 
 
+if _MS_WINDOWS:
+    def _path_isabs(path):
+        """Replacement for os.path.isabs."""
+        if not path:
+            return False
+        root = _os._path_splitroot(path)[0].replace('/', '\\')
+        return len(root) > 1 and (root.startswith('\\\\') or root.endswith('\\'))
+
+else:
+    def _path_isabs(path):
+        """Replacement for os.path.isabs."""
+        return path.startswith(path_separators)
+
+
 def _write_atomic(path, data, mode=0o666):
     """Best-effort function to write data to a path atomically.
     Be prepared to handle a FileExistsError if concurrent writing of the
@@ -248,6 +323,21 @@ def _write_atomic(path, data, mode=0o666):
 #     Python 3.7b1  3393 (remove STORE_ANNOTATION opcode #32550)
 #     Python 3.7b5  3394 (restored docstring as the first stmt in the body;
 #                         this might affected the first line number #32911)
+#     Python 3.8a1  3400 (move frame block handling to compiler #17611)
+#     Python 3.8a1  3401 (add END_ASYNC_FOR #33041)
+#     Python 3.8a1  3410 (PEP570 Python Positional-Only Parameters #36540)
+#     Python 3.8b2  3411 (Reverse evaluation order of key: value in dict
+#                         comprehensions #35224)
+#     Python 3.8b2  3412 (Swap the position of positional args and positional
+#                         only args in ast.arguments #37593)
+#     Python 3.8b4  3413 (Fix "break" and "continue" in "finally" #37830)
+#     Python 3.9a0  3420 (add LOAD_ASSERTION_ERROR #34880)
+#     Python 3.9a0  3421 (simplified bytecode for with blocks #32949)
+#     Python 3.9a0  3422 (remove BEGIN_FINALLY, END_FINALLY, CALL_FINALLY, POP_FINALLY bytecodes #33387)
+#     Python 3.9a2  3423 (add IS_OP, CONTAINS_OP and JUMP_IF_NOT_EXC_MATCH bytecodes #39156)
+#     Python 3.9a2  3424 (simplify bytecodes for *value unpacking)
+#     Python 3.9a2  3425 (simplify bytecodes for **value unpacking)
+
 #
 # MAGIC must change whenever the bytecode emitted by the compiler may no
 # longer be understood by older implementations of the eval loop (usually
@@ -256,7 +346,7 @@ def _write_atomic(path, data, mode=0o666):
 # Whenever MAGIC_NUMBER is changed, the ranges in the magic_values array
 # in PC/launcher.c must also be updated.
 
-MAGIC_NUMBER = (3394).to_bytes(2, 'little') + b'\r\n'
+MAGIC_NUMBER = (3425).to_bytes(2, 'little') + b'\r\n'
 _RAW_MAGIC_NUMBER = int.from_bytes(MAGIC_NUMBER, 'little')  # For import.c
 
 _PYCACHE = '__pycache__'
@@ -310,7 +400,33 @@ def cache_from_source(path, debug_override=None, *, optimization=None):
         if not optimization.isalnum():
             raise ValueError('{!r} is not alphanumeric'.format(optimization))
         almost_filename = '{}.{}{}'.format(almost_filename, _OPT, optimization)
-    return _path_join(head, _PYCACHE, almost_filename + BYTECODE_SUFFIXES[0])
+    filename = almost_filename + BYTECODE_SUFFIXES[0]
+    if sys.pycache_prefix is not None:
+        # We need an absolute path to the py file to avoid the possibility of
+        # collisions within sys.pycache_prefix, if someone has two different
+        # `foo/bar.py` on their system and they import both of them using the
+        # same sys.pycache_prefix. Let's say sys.pycache_prefix is
+        # `C:\Bytecode`; the idea here is that if we get `Foo\Bar`, we first
+        # make it absolute (`C:\Somewhere\Foo\Bar`), then make it root-relative
+        # (`Somewhere\Foo\Bar`), so we end up placing the bytecode file in an
+        # unambiguous `C:\Bytecode\Somewhere\Foo\Bar\`.
+        if not _path_isabs(head):
+            head = _path_join(_os.getcwd(), head)
+
+        # Strip initial drive from a Windows path. We know we have an absolute
+        # path here, so the second part of the check rules out a POSIX path that
+        # happens to contain a colon at the second character.
+        if head[1] == ':' and head[0] not in path_separators:
+            head = head[2:]
+
+        # Strip initial path separator from `head` to complete the conversion
+        # back to a root-relative path before joining.
+        return _path_join(
+            sys.pycache_prefix,
+            head.lstrip(path_separators),
+            filename,
+        )
+    return _path_join(head, _PYCACHE, filename)
 
 
 def source_from_cache(path):
@@ -326,23 +442,29 @@ def source_from_cache(path):
         raise NotImplementedError('sys.implementation.cache_tag is None')
     path = _os.fspath(path)
     head, pycache_filename = _path_split(path)
-    head, pycache = _path_split(head)
-    if pycache != _PYCACHE:
-        raise ValueError('{} not bottom-level directory in '
-                         '{!r}'.format(_PYCACHE, path))
+    found_in_pycache_prefix = False
+    if sys.pycache_prefix is not None:
+        stripped_path = sys.pycache_prefix.rstrip(path_separators)
+        if head.startswith(stripped_path + path_sep):
+            head = head[len(stripped_path):]
+            found_in_pycache_prefix = True
+    if not found_in_pycache_prefix:
+        head, pycache = _path_split(head)
+        if pycache != _PYCACHE:
+            raise ValueError(f'{_PYCACHE} not bottom-level directory in '
+                             f'{path!r}')
     dot_count = pycache_filename.count('.')
     if dot_count not in {2, 3}:
-        raise ValueError('expected only 2 or 3 dots in '
-                         '{!r}'.format(pycache_filename))
+        raise ValueError(f'expected only 2 or 3 dots in {pycache_filename!r}')
     elif dot_count == 3:
         optimization = pycache_filename.rsplit('.', 2)[-2]
         if not optimization.startswith(_OPT):
             raise ValueError("optimization portion of filename does not start "
-                             "with {!r}".format(_OPT))
+                             f"with {_OPT!r}")
         opt_level = optimization[len(_OPT):]
         if not opt_level.isalnum():
-            raise ValueError("optimization level {!r} is not an alphanumeric "
-                             "value".format(optimization))
+            raise ValueError(f"optimization level {optimization!r} is not an "
+                             "alphanumeric value")
     base_filename = pycache_filename.partition('.')[0]
     return _path_join(head, base_filename + SOURCE_SUFFIXES[0])
 
@@ -460,7 +582,7 @@ def _classify_pyc(data, name, exc_details):
         message = f'reached EOF while reading pyc header of {name!r}'
         _bootstrap._verbose_message('{}', message)
         raise EOFError(message)
-    flags = _r_long(data[4:8])
+    flags = _unpack_uint32(data[4:8])
     # Only the first two flags are defined.
     if flags & ~0b11:
         message = f'invalid flags {flags!r} in {name!r}'
@@ -487,12 +609,12 @@ def _validate_timestamp_pyc(data, source_mtime, source_size, name,
     An ImportError is raised if the bytecode is stale.
 
     """
-    if _r_long(data[8:12]) != (source_mtime & 0xFFFFFFFF):
+    if _unpack_uint32(data[8:12]) != (source_mtime & 0xFFFFFFFF):
         message = f'bytecode is stale for {name!r}'
         _bootstrap._verbose_message('{}', message)
         raise ImportError(message, **exc_details)
     if (source_size is not None and
-        _r_long(data[12:16]) != (source_size & 0xFFFFFFFF)):
+        _unpack_uint32(data[12:16]) != (source_size & 0xFFFFFFFF)):
         raise ImportError(f'bytecode is stale for {name!r}', **exc_details)
 
 
@@ -536,9 +658,9 @@ def _compile_bytecode(data, name=None, bytecode_path=None, source_path=None):
 def _code_to_timestamp_pyc(code, mtime=0, source_size=0):
     "Produce the data for a timestamp-based pyc."
     data = bytearray(MAGIC_NUMBER)
-    data.extend(_w_long(0))
-    data.extend(_w_long(mtime))
-    data.extend(_w_long(source_size))
+    data.extend(_pack_uint32(0))
+    data.extend(_pack_uint32(mtime))
+    data.extend(_pack_uint32(source_size))
     data.extend(marshal.dumps(code))
     return data
 
@@ -547,7 +669,7 @@ def _code_to_hash_pyc(code, source_hash, checked=True):
     "Produce the data for a hash-based pyc."
     data = bytearray(MAGIC_NUMBER)
     flags = 0b1 | checked << 1
-    data.extend(_w_long(flags))
+    data.extend(_pack_uint32(flags))
     assert len(source_hash) == 8
     data.extend(source_hash)
     data.extend(marshal.dumps(code))
@@ -596,6 +718,11 @@ def spec_from_file_location(name, location=None, *, loader=None,
                 pass
     else:
         location = _os.fspath(location)
+        if not _path_isabs(location):
+            try:
+                location = _path_join(_os.getcwd(), location)
+            except OSError:
+                pass
 
     # If the location is on the filesystem, but doesn't actually exist,
     # we could return None here, indicating that the location is not
@@ -654,9 +781,9 @@ class WindowsRegistryFinder:
     @classmethod
     def _open_registry(cls, key):
         try:
-            return _winreg.OpenKey(_winreg.HKEY_CURRENT_USER, key)
+            return winreg.OpenKey(winreg.HKEY_CURRENT_USER, key)
         except OSError:
-            return _winreg.OpenKey(_winreg.HKEY_LOCAL_MACHINE, key)
+            return winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, key)
 
     @classmethod
     def _search_registry(cls, fullname):
@@ -668,7 +795,7 @@ def _search_registry(cls, fullname):
                                   sys_version='%d.%d' % sys.version_info[:2])
         try:
             with cls._open_registry(key) as hkey:
-                filepath = _winreg.QueryValue(hkey, '')
+                filepath = winreg.QueryValue(hkey, '')
         except OSError:
             return None
         return filepath
@@ -736,15 +863,16 @@ class SourceLoader(_LoaderBasics):
 
     def path_mtime(self, path):
         """Optional method that returns the modification time (an int) for the
-        specified path, where path is a str.
+        specified path (a str).
 
         Raises OSError when the path cannot be handled.
         """
         raise OSError
 
     def path_stats(self, path):
-        """Optional method returning a metadata dict for the specified path
-        to by the path (str).
+        """Optional method returning a metadata dict for the specified
+        path (a str).
+
         Possible keys:
         - 'mtime' (mandatory) is the numeric timestamp of last source
           code modification;
@@ -870,7 +998,6 @@ def get_code(self, fullname):
                                               len(source_bytes))
             try:
                 self._cache_bytecode(source_path, bytecode_path, data)
-                _bootstrap._verbose_message('wrote {!r}', bytecode_path)
             except NotImplementedError:
                 pass
         return code_object
@@ -913,8 +1040,12 @@ def get_filename(self, fullname):
 
     def get_data(self, path):
         """Return the data from path as raw bytes."""
-        with _io.FileIO(path, 'r') as file:
-            return file.read()
+        if isinstance(self, (SourceLoader, ExtensionFileLoader)):
+            with _io.open_code(str(path)) as file:
+                return file.read()
+        else:
+            with _io.FileIO(path, 'r') as file:
+                return file.read()
 
     # ResourceReader ABC API.
 
@@ -1114,6 +1245,9 @@ def _recalculate(self):
     def __iter__(self):
         return iter(self._recalculate())
 
+    def __getitem__(self, index):
+        return self._recalculate()[index]
+
     def __setitem__(self, index, path):
         self._path[index] = path
 
@@ -1306,6 +1440,19 @@ def find_module(cls, fullname, path=None):
             return None
         return spec.loader
 
+    @classmethod
+    def find_distributions(cls, *args, **kwargs):
+        """
+        Find distributions.
+
+        Return an iterable of all Distribution instances capable of
+        loading the metadata for packages matching ``context.name``
+        (or all names if ``None`` indicated) along the paths in the list
+        of directories ``context.path``.
+        """
+        from importlib.metadata import MetadataPathFinder
+        return MetadataPathFinder.find_distributions(*args, **kwargs)
+
 
 class FileFinder:
 
@@ -1326,6 +1473,8 @@ def __init__(self, path, *loader_details):
         self._loaders = loaders
         # Base (directory) path
         self.path = path or '.'
+        if not _path_isabs(self.path):
+            self.path = _path_join(_os.getcwd(), self.path)
         self._path_mtime = -1
         self._path_cache = set()
         self._relaxed_path_cache = set()
@@ -1388,7 +1537,10 @@ def find_spec(self, fullname, target=None):
                 is_namespace = _path_isdir(base_path)
         # Check for a file w/ a proper suffix exists.
         for suffix, loader_class in self._loaders:
-            full_path = _path_join(self.path, tail_module + suffix)
+            try:
+                full_path = _path_join(self.path, tail_module + suffix)
+            except ValueError:
+                return None
             _bootstrap._verbose_message('trying {}', full_path, verbosity=2)
             if cache_module + suffix in cache:
                 if _path_isfile(full_path):
@@ -1502,14 +1654,7 @@ def _setup(_bootstrap_module):
     sys = _bootstrap.sys
     _imp = _bootstrap._imp
 
-    # Directly load built-in modules needed during bootstrap.
     self_module = sys.modules[__name__]
-    for builtin_name in ('_io', '_warnings', 'builtins', 'marshal'):
-        if builtin_name not in sys.modules:
-            builtin_module = _bootstrap._builtin_from_name(builtin_name)
-        else:
-            builtin_module = sys.modules[builtin_name]
-        setattr(self_module, builtin_name, builtin_module)
 
     # Directly load the os module (needed during bootstrap).
     os_details = ('posix', ['/']), ('nt', ['\\', '/'])
@@ -1528,22 +1673,22 @@ def _setup(_bootstrap_module):
                 continue
     else:
         raise ImportError('importlib requires posix or nt')
+
     setattr(self_module, '_os', os_module)
     setattr(self_module, 'path_sep', path_sep)
     setattr(self_module, 'path_separators', ''.join(path_separators))
+    setattr(self_module, '_pathseps_with_colon', {f':{s}' for s in path_separators})
 
-    # Directly load the _thread module (needed during bootstrap).
-    thread_module = _bootstrap._builtin_from_name('_thread')
-    setattr(self_module, '_thread', thread_module)
-
-    # Directly load the _weakref module (needed during bootstrap).
-    weakref_module = _bootstrap._builtin_from_name('_weakref')
-    setattr(self_module, '_weakref', weakref_module)
-
-    # Directly load the winreg module (needed during bootstrap).
+    # Directly load built-in modules needed during bootstrap.
+    builtin_names = ['_io', '_warnings', 'marshal']
     if builtin_os == 'nt':
-        winreg_module = _bootstrap._builtin_from_name('winreg')
-        setattr(self_module, '_winreg', winreg_module)
+        builtin_names.append('winreg')
+    for builtin_name in builtin_names:
+        if builtin_name not in sys.modules:
+            builtin_module = _bootstrap._builtin_from_name(builtin_name)
+        else:
+            builtin_module = sys.modules[builtin_name]
+        setattr(self_module, builtin_name, builtin_module)
 
     # Constants
     setattr(self_module, '_relax_case', _make_relax_case())
diff --git a/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/_common.py b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/_common.py
new file mode 100644
index 0000000..c1204f0
--- /dev/null
+++ b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/_common.py
@@ -0,0 +1,62 @@
+import os
+import pathlib
+import zipfile
+import tempfile
+import functools
+import contextlib
+
+
+def from_package(package):
+    """
+    Return a Traversable object for the given package.
+
+    """
+    return fallback_resources(package.__spec__)
+
+
+def fallback_resources(spec):
+    package_directory = pathlib.Path(spec.origin).parent
+    try:
+        archive_path = spec.loader.archive
+        rel_path = package_directory.relative_to(archive_path)
+        return zipfile.Path(archive_path, str(rel_path) + '/')
+    except Exception:
+        pass
+    return package_directory
+
+
+@contextlib.contextmanager
+def _tempfile(reader, suffix=''):
+    # Not using tempfile.NamedTemporaryFile as it leads to deeper 'try'
+    # blocks due to the need to close the temporary file to work on Windows
+    # properly.
+    fd, raw_path = tempfile.mkstemp(suffix=suffix)
+    try:
+        os.write(fd, reader())
+        os.close(fd)
+        yield pathlib.Path(raw_path)
+    finally:
+        try:
+            os.remove(raw_path)
+        except FileNotFoundError:
+            pass
+
+
+@functools.singledispatch
+@contextlib.contextmanager
+def as_file(path):
+    """
+    Given a Traversable object, return that object as a
+    path on the local file system in a context manager.
+    """
+    with _tempfile(path.read_bytes, suffix=path.name) as local:
+        yield local
+
+
+@as_file.register(pathlib.Path)
+@contextlib.contextmanager
+def _(path):
+    """
+    Degenerate behavior for pathlib.Path objects.
+    """
+    yield path
diff --git a/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/abc.py b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/abc.py
index 4b2d3de..b8a9bb1 100644
--- a/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/abc.py
+++ b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/abc.py
@@ -10,10 +10,11 @@
     _frozen_importlib = None
 try:
     import _frozen_importlib_external
-except ImportError as exc:
+except ImportError:
     _frozen_importlib_external = _bootstrap_external
 import abc
 import warnings
+from typing import Protocol, runtime_checkable
 
 
 def _register(abstract_cls, *classes):
@@ -386,3 +387,88 @@ def contents(self):
 
 
 _register(ResourceReader, machinery.SourceFileLoader)
+
+
+@runtime_checkable
+class Traversable(Protocol):
+    """
+    An object with a subset of pathlib.Path methods suitable for
+    traversing directories and opening files.
+    """
+
+    @abc.abstractmethod
+    def iterdir(self):
+        """
+        Yield Traversable objects in self
+        """
+
+    @abc.abstractmethod
+    def read_bytes(self):
+        """
+        Read contents of self as bytes
+        """
+
+    @abc.abstractmethod
+    def read_text(self, encoding=None):
+        """
+        Read contents of self as bytes
+        """
+
+    @abc.abstractmethod
+    def is_dir(self):
+        """
+        Return True if self is a dir
+        """
+
+    @abc.abstractmethod
+    def is_file(self):
+        """
+        Return True if self is a file
+        """
+
+    @abc.abstractmethod
+    def joinpath(self, child):
+        """
+        Return Traversable child in self
+        """
+
+    @abc.abstractmethod
+    def __truediv__(self, child):
+        """
+        Return Traversable child in self
+        """
+
+    @abc.abstractmethod
+    def open(self, mode='r', *args, **kwargs):
+        """
+        mode may be 'r' or 'rb' to open as text or binary. Return a handle
+        suitable for reading (same as pathlib.Path.open).
+
+        When opening as text, accepts encoding parameters such as those
+        accepted by io.TextIOWrapper.
+        """
+
+    @abc.abstractproperty
+    def name(self):
+        # type: () -> str
+        """
+        The base name of this object without any parent references.
+        """
+
+
+class TraversableResources(ResourceReader):
+    @abc.abstractmethod
+    def files(self):
+        """Return a Traversable object for the loaded package."""
+
+    def open_resource(self, resource):
+        return self.files().joinpath(resource).open('rb')
+
+    def resource_path(self, resource):
+        raise FileNotFoundError(resource)
+
+    def is_resource(self, path):
+        return self.files().joinpath(path).isfile()
+
+    def contents(self):
+        return (item.name for item in self.files().iterdir())
diff --git a/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/metadata.py b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/metadata.py
new file mode 100644
index 0000000..ffa0cba
--- /dev/null
+++ b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/metadata.py
@@ -0,0 +1,586 @@
+import io
+import os
+import re
+import abc
+import csv
+import sys
+import email
+import pathlib
+import zipfile
+import operator
+import functools
+import itertools
+import posixpath
+import collections
+
+from configparser import ConfigParser
+from contextlib import suppress
+from importlib import import_module
+from importlib.abc import MetaPathFinder
+from itertools import starmap
+
+
+__all__ = [
+    'Distribution',
+    'DistributionFinder',
+    'PackageNotFoundError',
+    'distribution',
+    'distributions',
+    'entry_points',
+    'files',
+    'metadata',
+    'requires',
+    'version',
+    ]
+
+
+class PackageNotFoundError(ModuleNotFoundError):
+    """The package was not found."""
+
+
+class EntryPoint(
+        collections.namedtuple('EntryPointBase', 'name value group')):
+    """An entry point as defined by Python packaging conventions.
+
+    See `the packaging docs on entry points
+    <https://packaging.python.org/specifications/entry-points/>`_
+    for more information.
+    """
+
+    pattern = re.compile(
+        r'(?P<module>[\w.]+)\s*'
+        r'(:\s*(?P<attr>[\w.]+))?\s*'
+        r'(?P<extras>\[.*\])?\s*$'
+        )
+    """
+    A regular expression describing the syntax for an entry point,
+    which might look like:
+
+        - module
+        - package.module
+        - package.module:attribute
+        - package.module:object.attribute
+        - package.module:attr [extra1, extra2]
+
+    Other combinations are possible as well.
+
+    The expression is lenient about whitespace around the ':',
+    following the attr, and following any extras.
+    """
+
+    def load(self):
+        """Load the entry point from its definition. If only a module
+        is indicated by the value, return that module. Otherwise,
+        return the named object.
+        """
+        match = self.pattern.match(self.value)
+        module = import_module(match.group('module'))
+        attrs = filter(None, (match.group('attr') or '').split('.'))
+        return functools.reduce(getattr, attrs, module)
+
+    @property
+    def module(self):
+        match = self.pattern.match(self.value)
+        return match.group('module')
+
+    @property
+    def attr(self):
+        match = self.pattern.match(self.value)
+        return match.group('attr')
+
+    @property
+    def extras(self):
+        match = self.pattern.match(self.value)
+        return list(re.finditer(r'\w+', match.group('extras') or ''))
+
+    @classmethod
+    def _from_config(cls, config):
+        return [
+            cls(name, value, group)
+            for group in config.sections()
+            for name, value in config.items(group)
+            ]
+
+    @classmethod
+    def _from_text(cls, text):
+        config = ConfigParser(delimiters='=')
+        # case sensitive: https://stackoverflow.com/q/1611799/812183
+        config.optionxform = str
+        try:
+            config.read_string(text)
+        except AttributeError:  # pragma: nocover
+            # Python 2 has no read_string
+            config.readfp(io.StringIO(text))
+        return EntryPoint._from_config(config)
+
+    def __iter__(self):
+        """
+        Supply iter so one may construct dicts of EntryPoints easily.
+        """
+        return iter((self.name, self))
+
+    def __reduce__(self):
+        return (
+            self.__class__,
+            (self.name, self.value, self.group),
+            )
+
+
+class PackagePath(pathlib.PurePosixPath):
+    """A reference to a path in a package"""
+
+    def read_text(self, encoding='utf-8'):
+        with self.locate().open(encoding=encoding) as stream:
+            return stream.read()
+
+    def read_binary(self):
+        with self.locate().open('rb') as stream:
+            return stream.read()
+
+    def locate(self):
+        """Return a path-like object for this path"""
+        return self.dist.locate_file(self)
+
+
+class FileHash:
+    def __init__(self, spec):
+        self.mode, _, self.value = spec.partition('=')
+
+    def __repr__(self):
+        return '<FileHash mode: {} value: {}>'.format(self.mode, self.value)
+
+
+class Distribution:
+    """A Python distribution package."""
+
+    @abc.abstractmethod
+    def read_text(self, filename):
+        """Attempt to load metadata file given by the name.
+
+        :param filename: The name of the file in the distribution info.
+        :return: The text if found, otherwise None.
+        """
+
+    @abc.abstractmethod
+    def locate_file(self, path):
+        """
+        Given a path to a file in this distribution, return a path
+        to it.
+        """
+
+    @classmethod
+    def from_name(cls, name):
+        """Return the Distribution for the given package name.
+
+        :param name: The name of the distribution package to search for.
+        :return: The Distribution instance (or subclass thereof) for the named
+            package, if found.
+        :raises PackageNotFoundError: When the named package's distribution
+            metadata cannot be found.
+        """
+        for resolver in cls._discover_resolvers():
+            dists = resolver(DistributionFinder.Context(name=name))
+            dist = next(iter(dists), None)
+            if dist is not None:
+                return dist
+        else:
+            raise PackageNotFoundError(name)
+
+    @classmethod
+    def discover(cls, **kwargs):
+        """Return an iterable of Distribution objects for all packages.
+
+        Pass a ``context`` or pass keyword arguments for constructing
+        a context.
+
+        :context: A ``DistributionFinder.Context`` object.
+        :return: Iterable of Distribution objects for all packages.
+        """
+        context = kwargs.pop('context', None)
+        if context and kwargs:
+            raise ValueError("cannot accept context and kwargs")
+        context = context or DistributionFinder.Context(**kwargs)
+        return itertools.chain.from_iterable(
+            resolver(context)
+            for resolver in cls._discover_resolvers()
+            )
+
+    @staticmethod
+    def at(path):
+        """Return a Distribution for the indicated metadata path
+
+        :param path: a string or path-like object
+        :return: a concrete Distribution instance for the path
+        """
+        return PathDistribution(pathlib.Path(path))
+
+    @staticmethod
+    def _discover_resolvers():
+        """Search the meta_path for resolvers."""
+        declared = (
+            getattr(finder, 'find_distributions', None)
+            for finder in sys.meta_path
+            )
+        return filter(None, declared)
+
+    @classmethod
+    def _local(cls, root='.'):
+        from pep517 import build, meta
+        system = build.compat_system(root)
+        builder = functools.partial(
+            meta.build,
+            source_dir=root,
+            system=system,
+            )
+        return PathDistribution(zipfile.Path(meta.build_as_zip(builder)))
+
+    @property
+    def metadata(self):
+        """Return the parsed metadata for this Distribution.
+
+        The returned object will have keys that name the various bits of
+        metadata.  See PEP 566 for details.
+        """
+        text = (
+            self.read_text('METADATA')
+            or self.read_text('PKG-INFO')
+            # This last clause is here to support old egg-info files.  Its
+            # effect is to just end up using the PathDistribution's self._path
+            # (which points to the egg-info file) attribute unchanged.
+            or self.read_text('')
+            )
+        return email.message_from_string(text)
+
+    @property
+    def version(self):
+        """Return the 'Version' metadata for the distribution package."""
+        return self.metadata['Version']
+
+    @property
+    def entry_points(self):
+        return EntryPoint._from_text(self.read_text('entry_points.txt'))
+
+    @property
+    def files(self):
+        """Files in this distribution.
+
+        :return: List of PackagePath for this distribution or None
+
+        Result is `None` if the metadata file that enumerates files
+        (i.e. RECORD for dist-info or SOURCES.txt for egg-info) is
+        missing.
+        Result may be empty if the metadata exists but is empty.
+        """
+        file_lines = self._read_files_distinfo() or self._read_files_egginfo()
+
+        def make_file(name, hash=None, size_str=None):
+            result = PackagePath(name)
+            result.hash = FileHash(hash) if hash else None
+            result.size = int(size_str) if size_str else None
+            result.dist = self
+            return result
+
+        return file_lines and list(starmap(make_file, csv.reader(file_lines)))
+
+    def _read_files_distinfo(self):
+        """
+        Read the lines of RECORD
+        """
+        text = self.read_text('RECORD')
+        return text and text.splitlines()
+
+    def _read_files_egginfo(self):
+        """
+        SOURCES.txt might contain literal commas, so wrap each line
+        in quotes.
+        """
+        text = self.read_text('SOURCES.txt')
+        return text and map('"{}"'.format, text.splitlines())
+
+    @property
+    def requires(self):
+        """Generated requirements specified for this Distribution"""
+        reqs = self._read_dist_info_reqs() or self._read_egg_info_reqs()
+        return reqs and list(reqs)
+
+    def _read_dist_info_reqs(self):
+        return self.metadata.get_all('Requires-Dist')
+
+    def _read_egg_info_reqs(self):
+        source = self.read_text('requires.txt')
+        return source and self._deps_from_requires_text(source)
+
+    @classmethod
+    def _deps_from_requires_text(cls, source):
+        section_pairs = cls._read_sections(source.splitlines())
+        sections = {
+            section: list(map(operator.itemgetter('line'), results))
+            for section, results in
+            itertools.groupby(section_pairs, operator.itemgetter('section'))
+            }
+        return cls._convert_egg_info_reqs_to_simple_reqs(sections)
+
+    @staticmethod
+    def _read_sections(lines):
+        section = None
+        for line in filter(None, lines):
+            section_match = re.match(r'\[(.*)\]$', line)
+            if section_match:
+                section = section_match.group(1)
+                continue
+            yield locals()
+
+    @staticmethod
+    def _convert_egg_info_reqs_to_simple_reqs(sections):
+        """
+        Historically, setuptools would solicit and store 'extra'
+        requirements, including those with environment markers,
+        in separate sections. More modern tools expect each
+        dependency to be defined separately, with any relevant
+        extras and environment markers attached directly to that
+        requirement. This method converts the former to the
+        latter. See _test_deps_from_requires_text for an example.
+        """
+        def make_condition(name):
+            return name and 'extra == "{name}"'.format(name=name)
+
+        def parse_condition(section):
+            section = section or ''
+            extra, sep, markers = section.partition(':')
+            if extra and markers:
+                markers = '({markers})'.format(markers=markers)
+            conditions = list(filter(None, [markers, make_condition(extra)]))
+            return '; ' + ' and '.join(conditions) if conditions else ''
+
+        for section, deps in sections.items():
+            for dep in deps:
+                yield dep + parse_condition(section)
+
+
+class DistributionFinder(MetaPathFinder):
+    """
+    A MetaPathFinder capable of discovering installed distributions.
+    """
+
+    class Context:
+        """
+        Keyword arguments presented by the caller to
+        ``distributions()`` or ``Distribution.discover()``
+        to narrow the scope of a search for distributions
+        in all DistributionFinders.
+
+        Each DistributionFinder may expect any parameters
+        and should attempt to honor the canonical
+        parameters defined below when appropriate.
+        """
+
+        name = None
+        """
+        Specific name for which a distribution finder should match.
+        A name of ``None`` matches all distributions.
+        """
+
+        def __init__(self, **kwargs):
+            vars(self).update(kwargs)
+
+        @property
+        def path(self):
+            """
+            The path that a distribution finder should search.
+
+            Typically refers to Python package paths and defaults
+            to ``sys.path``.
+            """
+            return vars(self).get('path', sys.path)
+
+    @abc.abstractmethod
+    def find_distributions(self, context=Context()):
+        """
+        Find distributions.
+
+        Return an iterable of all Distribution instances capable of
+        loading the metadata for packages matching the ``context``,
+        a DistributionFinder.Context instance.
+        """
+
+
+class FastPath:
+    """
+    Micro-optimized class for searching a path for
+    children.
+    """
+
+    def __init__(self, root):
+        self.root = root
+        self.base = os.path.basename(self.root).lower()
+
+    def joinpath(self, child):
+        return pathlib.Path(self.root, child)
+
+    def children(self):
+        with suppress(Exception):
+            return os.listdir(self.root or '')
+        with suppress(Exception):
+            return self.zip_children()
+        return []
+
+    def zip_children(self):
+        zip_path = zipfile.Path(self.root)
+        names = zip_path.root.namelist()
+        self.joinpath = zip_path.joinpath
+
+        return dict.fromkeys(
+            child.split(posixpath.sep, 1)[0]
+            for child in names
+            )
+
+    def is_egg(self, search):
+        base = self.base
+        return (
+            base == search.versionless_egg_name
+            or base.startswith(search.prefix)
+            and base.endswith('.egg'))
+
+    def search(self, name):
+        for child in self.children():
+            n_low = child.lower()
+            if (n_low in name.exact_matches
+                    or n_low.startswith(name.prefix)
+                    and n_low.endswith(name.suffixes)
+                    # legacy case:
+                    or self.is_egg(name) and n_low == 'egg-info'):
+                yield self.joinpath(child)
+
+
+class Prepared:
+    """
+    A prepared search for metadata on a possibly-named package.
+    """
+    normalized = ''
+    prefix = ''
+    suffixes = '.dist-info', '.egg-info'
+    exact_matches = [''][:0]
+    versionless_egg_name = ''
+
+    def __init__(self, name):
+        self.name = name
+        if name is None:
+            return
+        self.normalized = name.lower().replace('-', '_')
+        self.prefix = self.normalized + '-'
+        self.exact_matches = [
+            self.normalized + suffix for suffix in self.suffixes]
+        self.versionless_egg_name = self.normalized + '.egg'
+
+
+class MetadataPathFinder(DistributionFinder):
+    @classmethod
+    def find_distributions(cls, context=DistributionFinder.Context()):
+        """
+        Find distributions.
+
+        Return an iterable of all Distribution instances capable of
+        loading the metadata for packages matching ``context.name``
+        (or all names if ``None`` indicated) along the paths in the list
+        of directories ``context.path``.
+        """
+        found = cls._search_paths(context.name, context.path)
+        return map(PathDistribution, found)
+
+    @classmethod
+    def _search_paths(cls, name, paths):
+        """Find metadata directories in paths heuristically."""
+        return itertools.chain.from_iterable(
+            path.search(Prepared(name))
+            for path in map(FastPath, paths)
+            )
+
+
+class PathDistribution(Distribution):
+    def __init__(self, path):
+        """Construct a distribution from a path to the metadata directory.
+
+        :param path: A pathlib.Path or similar object supporting
+                     .joinpath(), __div__, .parent, and .read_text().
+        """
+        self._path = path
+
+    def read_text(self, filename):
+        with suppress(FileNotFoundError, IsADirectoryError, KeyError,
+                      NotADirectoryError, PermissionError):
+            return self._path.joinpath(filename).read_text(encoding='utf-8')
+    read_text.__doc__ = Distribution.read_text.__doc__
+
+    def locate_file(self, path):
+        return self._path.parent / path
+
+
+def distribution(distribution_name):
+    """Get the ``Distribution`` instance for the named package.
+
+    :param distribution_name: The name of the distribution package as a string.
+    :return: A ``Distribution`` instance (or subclass thereof).
+    """
+    return Distribution.from_name(distribution_name)
+
+
+def distributions(**kwargs):
+    """Get all ``Distribution`` instances in the current environment.
+
+    :return: An iterable of ``Distribution`` instances.
+    """
+    return Distribution.discover(**kwargs)
+
+
+def metadata(distribution_name):
+    """Get the metadata for the named package.
+
+    :param distribution_name: The name of the distribution package to query.
+    :return: An email.Message containing the parsed metadata.
+    """
+    return Distribution.from_name(distribution_name).metadata
+
+
+def version(distribution_name):
+    """Get the version string for the named package.
+
+    :param distribution_name: The name of the distribution package to query.
+    :return: The version string for the package as defined in the package's
+        "Version" metadata key.
+    """
+    return distribution(distribution_name).version
+
+
+def entry_points():
+    """Return EntryPoint objects for all installed packages.
+
+    :return: EntryPoint objects for all installed packages.
+    """
+    eps = itertools.chain.from_iterable(
+        dist.entry_points for dist in distributions())
+    by_group = operator.attrgetter('group')
+    ordered = sorted(eps, key=by_group)
+    grouped = itertools.groupby(ordered, by_group)
+    return {
+        group: tuple(eps)
+        for group, eps in grouped
+        }
+
+
+def files(distribution_name):
+    """Return a list of files for the named package.
+
+    :param distribution_name: The name of the distribution package to query.
+    :return: List of files composing the distribution.
+    """
+    return distribution(distribution_name).files
+
+
+def requires(distribution_name):
+    """
+    Return a list of requirements for the named package.
+
+    :return: An iterator of requirements, suitable for
+    packaging.requirement.Requirement.
+    """
+    return distribution(distribution_name).requires
diff --git a/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/resources.py b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/resources.py
index cbefdd5..b803a01 100644
--- a/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/resources.py
+++ b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/resources.py
@@ -1,23 +1,25 @@
 import os
-import tempfile
 
 from . import abc as resources_abc
+from . import _common
+from ._common import as_file
 from contextlib import contextmanager, suppress
 from importlib import import_module
 from importlib.abc import ResourceLoader
 from io import BytesIO, TextIOWrapper
 from pathlib import Path
 from types import ModuleType
-from typing import Iterable, Iterator, Optional, Set, Union   # noqa: F401
+from typing import ContextManager, Iterable, Optional, Union
 from typing import cast
 from typing.io import BinaryIO, TextIO
-from zipimport import ZipImportError
 
 
 __all__ = [
     'Package',
     'Resource',
+    'as_file',
     'contents',
+    'files',
     'is_resource',
     'open_binary',
     'open_text',
@@ -31,24 +33,23 @@
 Resource = Union[str, os.PathLike]
 
 
+def _resolve(name) -> ModuleType:
+    """If name is a string, resolve to a module."""
+    if hasattr(name, '__spec__'):
+        return name
+    return import_module(name)
+
+
 def _get_package(package) -> ModuleType:
     """Take a package name or module object and return the module.
 
-    If a name, the module is imported.  If the passed or imported module
+    If a name, the module is imported.  If the resolved module
     object is not a package, raise an exception.
     """
-    if hasattr(package, '__spec__'):
-        if package.__spec__.submodule_search_locations is None:
-            raise TypeError('{!r} is not a package'.format(
-                package.__spec__.name))
-        else:
-            return package
-    else:
-        module = import_module(package)
-        if module.__spec__.submodule_search_locations is None:
-            raise TypeError('{!r} is not a package'.format(package))
-        else:
-            return module
+    module = _resolve(package)
+    if module.__spec__.submodule_search_locations is None:
+        raise TypeError('{!r} is not a package'.format(package))
+    return module
 
 
 def _normalize_path(path) -> str:
@@ -59,8 +60,7 @@ def _normalize_path(path) -> str:
     parent, file_name = os.path.split(path)
     if parent:
         raise ValueError('{!r} must be only a file name'.format(path))
-    else:
-        return file_name
+    return file_name
 
 
 def _get_resource_reader(
@@ -89,8 +89,8 @@ def open_binary(package: Package, resource: Resource) -> BinaryIO:
     reader = _get_resource_reader(package)
     if reader is not None:
         return reader.open_resource(resource)
-    _check_location(package)
-    absolute_package_path = os.path.abspath(package.__spec__.origin)
+    absolute_package_path = os.path.abspath(
+        package.__spec__.origin or 'non-existent file')
     package_path = os.path.dirname(absolute_package_path)
     full_path = os.path.join(package_path, resource)
     try:
@@ -109,8 +109,7 @@ def open_binary(package: Package, resource: Resource) -> BinaryIO:
             message = '{!r} resource not found in {!r}'.format(
                 resource, package_name)
             raise FileNotFoundError(message)
-        else:
-            return BytesIO(data)
+        return BytesIO(data)
 
 
 def open_text(package: Package,
@@ -118,39 +117,12 @@ def open_text(package: Package,
               encoding: str = 'utf-8',
               errors: str = 'strict') -> TextIO:
     """Return a file-like object opened for text reading of the resource."""
-    resource = _normalize_path(resource)
-    package = _get_package(package)
-    reader = _get_resource_reader(package)
-    if reader is not None:
-        return TextIOWrapper(reader.open_resource(resource), encoding, errors)
-    _check_location(package)
-    absolute_package_path = os.path.abspath(package.__spec__.origin)
-    package_path = os.path.dirname(absolute_package_path)
-    full_path = os.path.join(package_path, resource)
-    try:
-        return open(full_path, mode='r', encoding=encoding, errors=errors)
-    except OSError:
-        # Just assume the loader is a resource loader; all the relevant
-        # importlib.machinery loaders are and an AttributeError for
-        # get_data() will make it clear what is needed from the loader.
-        loader = cast(ResourceLoader, package.__spec__.loader)
-        data = None
-        if hasattr(package.__spec__.loader, 'get_data'):
-            with suppress(OSError):
-                data = loader.get_data(full_path)
-        if data is None:
-            package_name = package.__spec__.name
-            message = '{!r} resource not found in {!r}'.format(
-                resource, package_name)
-            raise FileNotFoundError(message)
-        else:
-            return TextIOWrapper(BytesIO(data), encoding, errors)
+    return TextIOWrapper(
+        open_binary(package, resource), encoding=encoding, errors=errors)
 
 
 def read_binary(package: Package, resource: Resource) -> bytes:
     """Return the binary contents of the resource."""
-    resource = _normalize_path(resource)
-    package = _get_package(package)
     with open_binary(package, resource) as fp:
         return fp.read()
 
@@ -164,14 +136,20 @@ def read_text(package: Package,
     The decoding-related arguments have the same semantics as those of
     bytes.decode().
     """
-    resource = _normalize_path(resource)
-    package = _get_package(package)
     with open_text(package, resource, encoding, errors) as fp:
         return fp.read()
 
 
-@contextmanager
-def path(package: Package, resource: Resource) -> Iterator[Path]:
+def files(package: Package) -> resources_abc.Traversable:
+    """
+    Get a Traversable resource from a package
+    """
+    return _common.from_package(_get_package(package))
+
+
+def path(
+        package: Package, resource: Resource,
+        ) -> 'ContextManager[Path]':
     """A context manager providing a file path object to the resource.
 
     If the resource does not already exist on its own on the file system,
@@ -180,39 +158,23 @@ def path(package: Package, resource: Resource) -> Iterator[Path]:
     raised if the file was deleted prior to the context manager
     exiting).
     """
-    resource = _normalize_path(resource)
-    package = _get_package(package)
-    reader = _get_resource_reader(package)
-    if reader is not None:
-        try:
-            yield Path(reader.resource_path(resource))
-            return
-        except FileNotFoundError:
-            pass
-    else:
-        _check_location(package)
-    # Fall-through for both the lack of resource_path() *and* if
-    # resource_path() raises FileNotFoundError.
-    package_directory = Path(package.__spec__.origin).parent
-    file_path = package_directory / resource
-    if file_path.exists():
-        yield file_path
-    else:
-        with open_binary(package, resource) as fp:
-            data = fp.read()
-        # Not using tempfile.NamedTemporaryFile as it leads to deeper 'try'
-        # blocks due to the need to close the temporary file to work on
-        # Windows properly.
-        fd, raw_path = tempfile.mkstemp()
-        try:
-            os.write(fd, data)
-            os.close(fd)
-            yield Path(raw_path)
-        finally:
-            try:
-                os.remove(raw_path)
-            except FileNotFoundError:
-                pass
+    reader = _get_resource_reader(_get_package(package))
+    return (
+        _path_from_reader(reader, resource)
+        if reader else
+        _common.as_file(files(package).joinpath(_normalize_path(resource)))
+        )
+
+
+@contextmanager
+def _path_from_reader(reader, resource):
+    norm_resource = _normalize_path(resource)
+    with suppress(FileNotFoundError):
+        yield Path(reader.resource_path(norm_resource))
+        return
+    opener_reader = reader.open_resource(norm_resource)
+    with _common._tempfile(opener_reader.read, suffix=norm_resource) as res:
+        yield res
 
 
 def is_resource(package: Package, name: str) -> bool:
@@ -225,17 +187,10 @@ def is_resource(package: Package, name: str) -> bool:
     reader = _get_resource_reader(package)
     if reader is not None:
         return reader.is_resource(name)
-    try:
-        package_contents = set(contents(package))
-    except (NotADirectoryError, FileNotFoundError):
-        return False
+    package_contents = set(contents(package))
     if name not in package_contents:
         return False
-    # Just because the given file_name lives as an entry in the package's
-    # contents doesn't necessarily mean it's a resource.  Directories are not
-    # resources, so let's try to find out if it's a directory or not.
-    path = Path(package.__spec__.origin).parent / name
-    return path.is_file()
+    return (_common.from_package(package) / name).is_file()
 
 
 def contents(package: Package) -> Iterable[str]:
@@ -250,94 +205,11 @@ def contents(package: Package) -> Iterable[str]:
     if reader is not None:
         return reader.contents()
     # Is the package a namespace package?  By definition, namespace packages
-    # cannot have resources.  We could use _check_location() and catch the
-    # exception, but that's extra work, so just inline the check.
-    elif package.__spec__.origin is None or not package.__spec__.has_location:
+    # cannot have resources.
+    namespace = (
+        package.__spec__.origin is None or
+        package.__spec__.origin == 'namespace'
+        )
+    if namespace or not package.__spec__.has_location:
         return ()
-    else:
-        package_directory = Path(package.__spec__.origin).parent
-        return os.listdir(package_directory)
-
-
-# Private implementation of ResourceReader and get_resource_reader() called
-# from zipimport.c.  Don't use these directly!  We're implementing these in
-# Python because 1) it's easier, 2) zipimport may get rewritten in Python
-# itself at some point, so doing this all in C would difficult and a waste of
-# effort.
-
-class _ZipImportResourceReader(resources_abc.ResourceReader):
-    """Private class used to support ZipImport.get_resource_reader().
-
-    This class is allowed to reference all the innards and private parts of
-    the zipimporter.
-    """
-
-    def __init__(self, zipimporter, fullname):
-        self.zipimporter = zipimporter
-        self.fullname = fullname
-
-    def open_resource(self, resource):
-        fullname_as_path = self.fullname.replace('.', '/')
-        path = f'{fullname_as_path}/{resource}'
-        try:
-            return BytesIO(self.zipimporter.get_data(path))
-        except OSError:
-            raise FileNotFoundError(path)
-
-    def resource_path(self, resource):
-        # All resources are in the zip file, so there is no path to the file.
-        # Raising FileNotFoundError tells the higher level API to extract the
-        # binary data and create a temporary file.
-        raise FileNotFoundError
-
-    def is_resource(self, name):
-        # Maybe we could do better, but if we can get the data, it's a
-        # resource.  Otherwise it isn't.
-        fullname_as_path = self.fullname.replace('.', '/')
-        path = f'{fullname_as_path}/{name}'
-        try:
-            self.zipimporter.get_data(path)
-        except OSError:
-            return False
-        return True
-
-    def contents(self):
-        # This is a bit convoluted, because fullname will be a module path,
-        # but _files is a list of file names relative to the top of the
-        # archive's namespace.  We want to compare file paths to find all the
-        # names of things inside the module represented by fullname.  So we
-        # turn the module path of fullname into a file path relative to the
-        # top of the archive, and then we iterate through _files looking for
-        # names inside that "directory".
-        fullname_path = Path(self.zipimporter.get_filename(self.fullname))
-        relative_path = fullname_path.relative_to(self.zipimporter.archive)
-        # Don't forget that fullname names a package, so its path will include
-        # __init__.py, which we want to ignore.
-        assert relative_path.name == '__init__.py'
-        package_path = relative_path.parent
-        subdirs_seen = set()
-        for filename in self.zipimporter._files:
-            try:
-                relative = Path(filename).relative_to(package_path)
-            except ValueError:
-                continue
-            # If the path of the file (which is relative to the top of the zip
-            # namespace), relative to the package given when the resource
-            # reader was created, has a parent, then it's a name in a
-            # subdirectory and thus we skip it.
-            parent_name = relative.parent.name
-            if len(parent_name) == 0:
-                yield relative.name
-            elif parent_name not in subdirs_seen:
-                subdirs_seen.add(parent_name)
-                yield parent_name
-
-
-# Called from zipimport.c
-def _zipimport_get_resource_reader(zipimporter, fullname):
-    try:
-        if not zipimporter.is_package(fullname):
-            return None
-    except ZipImportError:
-        return None
-    return _ZipImportResourceReader(zipimporter, fullname)
+    return list(item.name for item in _common.from_package(package).iterdir())
diff --git a/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/util.py b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/util.py
index 201e0f4..269a6fa 100644
--- a/Users/yitong/.pyenv/versions/3.7.12/lib/python3.7/importlib/util.py
+++ b/Users/yitong/.pyenv/versions/3.9.5/lib/python3.9/importlib/util.py
@@ -29,8 +29,8 @@ def resolve_name(name, package):
     if not name.startswith('.'):
         return name
     elif not package:
-        raise ValueError(f'no package specified for {repr(name)} '
-                         '(required for relative module names)')
+        raise ImportError(f'no package specified for {repr(name)} '
+                          '(required for relative module names)')
     level = 0
     for character in name:
         if character != '.':
