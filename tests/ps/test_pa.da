import functools
import sys
import pickle

import argparse
import importlib
import pickle
import time
import os
import gc

from ps import ps, AST, CODE


def time_now():
    #  elptime = time.perf_counter(); cputime = time.process_time()
    #  utime, stime, cutime, cstime, elapsed = os.times()  # windows: last 3 = 0
    #  return (elptime, cputime, utime, stime, cutime, cstime, elapsed)
    return os.times()


def time_dur(t1, t2, name):
    #  elptime1, cputime1, u1, s1, cu1, cs1, e1 = t1
    #  elptime2, cputime2, u2, s2, cu2, cs2, e2 = t2
    u1, s1, cu1, cs1, e1 = t1
    u2, s2, cu2, cs2, e2 = t2
#  print(f'{name}_tm_pf+pr\t{elptime2-elptime1}\t{cputime2-cputime1}')
    print(f'{name}_os_total\t{e2-e1}\t{u2-u1 + s2-s1 + cu2-cu1 + cs2-cs1}')
# print('%s_tm_pf+pr\t%s\t%s'% (name, elptime2-elptime1, cputime2-cputime1))
# print('%s_os_total\t%s\t%s'% (name, e2-e1, u2-u1 + s2-s1 + cu2-cu1 + cs2-cs1))


def timer(func):
    def wrapper_function(*args, **kwargs):
        gc.disable()

        t1 = time_now()
        func(*args, **kwargs)
        t2 = time_now()
        time_dur(t1, t2, 'run')

    return wrapper_function


class PA(process):
    def setup(ClassDef, Member, Name):
        self.defined = None
        self.extending = None
        self.desc = None
        self.roots = None


#    def rules(name = 'class_extends_rs'):
#    def rules(name = class_extends_rs):

    def rules(class_extends_rs):
        #    def rules_class_extends_rs():
        defined(c), if_(ClassDef(_, c, _, _, _, _))
        extending(c, b), if_(ClassDef(_, c, baselist, _, _, _),
                             Member(baselist, base, _), Name(base, b, _))

    @functools.lru_cache(maxsize=None)
    def height(c):
        return 0 if not some((_, _c) in extending)\
            else 1 + maxof(height(d), (d, _c) in extending)

    def rules(desc_rs):
        desc(c, r), if_(roots(r), extending(c, r))
        desc(c, r), if_(desc(b, r), extending(c, b))

    @functools.lru_cache(maxsize=None)
    def num_desc(r):
        return lenof(c, (c, _r) in desc)

    def run():
        num_defined = len(defined)
        num_extending = len(extending)
        avg_extending = num_extending/num_defined
        roots = setof(c, (_, c) in extending, not some((_c, _) in extending))
        print('____ result 2: defined, extending, roots:\t%s\t%s\t%s' %
              (num_defined, num_extending, len(roots)))

        max_height = maxof(height(r), r in roots)
        roots_max_height = setof(r, r in roots, height(r) == max_height)
        print('____ result 3: max_height, roots_max_height:\t%s\t%s' %
              (max_height, len(roots_max_height)))

        max_desc = maxof(num_desc(r), r in roots)
        roots_max_desc = setof(r, r in roots, num_desc(r) == max_desc)
        print('____ result 4: desc, max_desc, roots_max_desc:\t%s\t%s\t%s' %
              (len(desc), max_desc, len(roots_max_desc)))


class PA(process, PA):
    @timer
    def run(): super().run()


def main():

    parser = argparse.ArgumentParser()
    parser.add_argument('--bench', type=str, default='PA')
    parser.add_argument('--data', type=str, default=None)
    args = parser.parse_args()

    classPA = eval(args.bench)
    # file = importlib.import_module(args.bench)
    # classPA = eval('file.PA')
    # benches = [PA, PAopt] if args.bench == 'paper' else [classPA]
    data_path = args.data
    # dbs = ['numpy', 'django', 'sklearn', 'blender', 'pandas', 'mpl', 'scipy',
    #       'sympy', 'pytorch'] if args.bench == 'paper' else [db]

    if not data_path:
        data_path = '/Users/phd/Downloads/numpy'
    gc.disable()

    t0 = time_now()
    t1 = time_now()
    # print(db)

    db = dict()
    ps.read(source=data_path, target=db, encode=True)

    pa = new(classPA, [db['ClassDef'], db['Member'], db['Name']])
    start(pa)

    time_dur(t0, t1, 'init')
